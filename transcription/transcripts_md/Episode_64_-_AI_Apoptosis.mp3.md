Speaker A
You wanted to talk a little bit about an update on your WeMo situation, I believe.

Speaker B
Oh boy. Home automation, which is my favorite topic of all time.

Speaker A
It seems that way.

Speaker B
I do want to talk about home automation.

Speaker A
I have a, I have one home fun home automation hack to share.

Speaker B
I think you should go first.

Speaker A
I should go first. Okay, so I have you know, I have a couple Amazon echoes around so that I can do things like ask wait, what can I ask? Oh my God.

Speaker B
We should know what planes are flying nearby.

Speaker A
Exactly. I want to go to sleep. I've found that if you have one of these echoes, like somewhere where you don't want to be listening all the time, what you can do, you get one of the Wimo outlets and then you hook it up to the Alexa app stop. And you plug the echo into that Wimo switch into the Wimo outlet. So that way you can say echo, turn off the echo in the bedroom and then it turns itself off. And then you can't turn it back on with voice. At least not from that room.

Speaker B
But that's incredible.

Speaker A
But that way if you want to kill switch for your echo devices, you can activate it with your voice.

Speaker B
I actually super like that. It's like a built in Acellular apoptosis. Just like Alexa. Kill yourself.

Speaker A
It is like that, yeah.

Speaker B
That's really funny. That's much funnier than the thing that I have for you.

Speaker A
But that way so this is on the one that's like oh, never mind.

Speaker B
Is the idea that you don't necessarily want it listening in your bedroom or.

Speaker A
Yeah, that's exactly it. I'm trying to decide whether it's weird to say that there's an echo in my bedroom.

Speaker B
Right. Well, I keep two echoes in my bed.

Speaker A
If that's weird, that sounds fine, I ask it. Some days will be like, play rain sounds and then I just listen to rain sounds at night.

Speaker B
But then sometimes you're like, stop listening to, stop playing rain sounds and stop working at all.

Speaker A
Yeah, just like go away.

Speaker B
Yeah. That is really genius. I really love that. There's something about AI is coming and it's going to singularity is going to take over the world. But all we have to do is plug it into a smart light switch.

Speaker A
And then tell it to turn itself off.

Speaker B
Done. Easy.

Speaker A
Yeah, I should do that.

Speaker B
Give me your money. I can solve your problems.

Speaker A
Well, I can solve your problems.

Speaker B
I'll steal Chris's ideas and pond them off as my own.

Speaker A
Damn. What's your Wimo update?

Speaker B
Okay, so as you know, my house has a very strange electrical setup. You know, my living room has no light switches, so you can't control any lights in there, which is why I have this whole crazy Wimo set up in the first place. But my bathroom also has weird lights, so you know how you can have like an outlet, right? You can plug stuff into it. There's like two plugs.

Speaker A
Yes, that is how outlets work.

Speaker B
Right. And then sometimes those, like, it's the same shape in the same box, but it's like a switch you can flick on and off. Right?

Speaker A
Yeah. Okay.

Speaker B
Sometimes it's one outlet that you can plug into and one switch. Same size box, right? Okay. So we have that, except the switch is this little tiny thing, and it's like impossible to even realize that there's a switch there. Guests come over and they're like, how do I turn the lights on the bathroom? I have no idea. And then to make matters worse, we put this shelving system over the toilet. But the way it is, it kind of blocks off this outlet. And so you kind of have to slide your hand along in between the wall and the shelving unit to click this thing to turn the lights on.

Speaker A
Obviously, I was going to say most of these problems up until now seem like things you could solve by replacing it with a different light switch.

Speaker B
Okay, yes, you could. But the problem is that if we do that, then we have no outlets in the bathroom and my girlfriend needs to either straighten her blow dryer hair or whatever I need to shave and trim my beard.

Speaker A
I see.

Speaker B
Yes. So we need that outlet. The outlet can't go away, but then also we need the switch because obviously we need a way to turn lights on and off. So my thinking on this was and then the fact that we need the outlet is the reason that I can't replace that outlet with a wimo switch entirely. Because if I do, then that would replace the outlet, which we need.

Speaker A
Right, okay.

Speaker B
So far with me, right?

Speaker A
I think so.

Speaker B
Okay. So I was like, well, I would like to smartify these lights and maybe in the process I could make a switch that's a little bit better than the switch that we have. So what I did is I was like, I'll get two smart bulbs and then I'll get some kind of switch that can control the bulbs. I could even plug it in because there is a plug there and it's at like hand level, so I could actually plug it in. But I need to find that thing basically. Right. So what I did, I went on Amazon. I was being real cheap. I was like, you know what? I don't even know if this is going to work. I want to buy the cheapest smart light bulbs I can find that work with HomeKit.

Speaker A
Okay.

Speaker B
So I went and I found two I think they're sylvania bulbs, and they were like $15 each. They were really cheap.

Speaker A
This doesn't sound promising.

Speaker B
Yeah. So I go in and I go and install them, and then I hooked them up to HomeKit. They have WiFi chips inside them and the HomeKit actually the setup was really seamless. It was really easy to do. It worked great. I didn't need a hub. I didn't need anything like that. And I was like, oh, this is fantastic. I have all this stuff set up. And then I was like, okay, well, now I need to find a switch for this thing. So first of all, one thing that I didn't realize is when you have these smart light bulbs, if you flick the hardware switch off, obviously the power to the smart light bulb goes out.

Speaker A
Right?

Speaker B
So it goes out, but then when you flip it back on, it knows, hey, I just got electricity, I should turn on. It's kind of nice.

Speaker A
Yeah. Okay.

Speaker B
The light comes on, it acts like a light, like you would expect.

Speaker A
Yeah.

Speaker B
The problem is when you turn it off from the app and then you want to go turn it on and you go to flick the switch. And unbeknownst to you, that actually has turned off the power to the thing and you have to flick it again to turn it back on. So that's pretty horrible.

Speaker A
That sounds pretty rough.

Speaker B
Yeah, so you don't want that. So then I was like, okay, well, let me look around and find a smart switch that I can use. And it would be fine even if it plugged in, because obviously WiFi takes a lot of power. This can't be battery powered, right? So I figure, okay, it'll be WiFi. I'll just plug it into the wall and I'll get like a little outlet sort of extender thing for that one plug so we can have more plugs. And then I'll just plug in a button and you'll hit the button and then everything will be good. Turns out this thing that I want does not exist. You cannot just get a HomeKit button that just plugs into the wall. Just doesn't exist.

Speaker A
Nobody makes that plugs in. Rather than being like hardwired, right?

Speaker B
Yeah. That plugs in with like a two pronged outlet and it's just a button, does nothing else. It's just a button that sends HomeKit signals to something totally doesn't exist. There are some things that are Zwave or Zigbee which are like this other networking protocol.

Speaker A
You are so far down the rabbit hole.

Speaker B
I am really far rabbit hole. Zwave and Zigbee are like special low power signaling network things that are still wireless. They're invented for home automation because usually home automation stuff doesn't have any power you attach a smart detector for. If your doors open or closed, you can't plug that into the wall so you can't connect to WiFi from that. So you need something else.

Speaker A
That's what that stuff is typically much lower frequencies than WiFi, both because that'll give you longer range and also takes less power.

Speaker B
Yeah. Chris is the scientist. He knows the reasons that things are actually the way they are. But yeah, so this button doesn't exist. I don't want to get a Zigbee hub because you have to get a hub then to connect it to your real WiFi and everything else. So I was like, I don't want to get that. And I was like, all right, you know what? I will change tracks entirely and I will go to the Philips Hue family of products. And this is what people have. When people heard our Wimo episode, they were like, just get some hues and a tap switch. And so I did that's. What I did, I got a tap switch and I got a Hue starter kit, which is two white bulbs and one hub. Okay, so I screw in the light bulbs, I plug in the hub, and then the home kit setup was actually pretty painful, but I got it working.

Speaker A
That sounds about right.

Speaker B
Yeah. And then I got the tap switch working, which is like it's powered by every time you click it, it powers a little piezo electric thing and that charges it, which is cool. So you don't need to plug it in or use batteries or anything, which is pretty great. And then that has to connect to your hub, which is your Hue hub. So that all connects through that stuff. That's all working now, except for a couple of things. One, we had some guests here and the whole I don't know if you've ever seen a Phillips tap switch, but.

Speaker A
I don't think I have.

Speaker B
Yeah, so I'll put a link in the show notes, but it's basically a big circle and then there's three smaller circles on it and each of the smaller circles are very obviously buttons. But the whole thing is also a button. But it's not obvious, the whole thing.

Speaker A
This sounds really weird.

Speaker B
It's really strange. You'll see it?

Speaker A
Wait, the whole thing is also a button?

Speaker B
Yeah.

Speaker A
That's absurd. That's a terrible design. Why not?

Speaker B
Good, just give me a button anyway. I'm not angry. So there's four buttons on there. You can see like one has one dot, one has two dots, three dots and four dots. So that represents the four buttons. And then you can program them to different settings. So if you click the whole thing in, it will set it to on. If you click the second button, it'll set it to dimmed. Third will be like a little brighter but still dimmed. And then fourth is like fully on. So then to turn it on and off you have to push the four dot button, which is like the left most tiny button, but then to turn off you can push the whole thing. I was like, this is insane. I'm not going to remember which button to push based on what light is currently in. I just wanted to toggle the light. It turns out none of these buttons.

Speaker A
Just toggle the light.

Speaker B
None of them do. They just set the light to a stateless. It's stateless programming. It's functional. So then it turns out that if you go to the Philips Hue website, there's something called Hue Labs, where people have programmed with JavaScript different behaviors for the lights.

Speaker A
JavaScript the last thing I want involved in making lights come on in my apartment.

Speaker B
So what I did is I set the big button to Toggle, and there is a Toggle behavior, which is amazing. And so you just push the big button, it turns on. You push the big button, it turns off. Now, what are the downsides here? Number one, I haven't done this to buttons two, three and four. So if you accidentally think those are buttons, then you would push them and something totally different happens.

Speaker A
Make each of the buttons do just do the exact same thing.

Speaker B
Yeah, I need to. That's what I need to do. The other thing is that the toggle just toggles to the previously remembered state. So if you press Button Two and set it to dimmed and then you press the Big button, which toggles it'll turn it off. And then you press the Big button which toggles again and it goes back to the previously dimmed state, which is like remember in the early two thousand s and ninety s when you would hit undo and it would undo something and you would hit undo again and it would just undo the undo.

Speaker A
It still how photoshop works.

Speaker B
Yeah, I think it might be in Photoshop.

Speaker A
You want step backward, not undo.

Speaker B
Yeah, there's like a whole history pain. This is what this button does. It's maddening, but it works. And then we had guests, they came and they were like, we don't understand which button to press. We tried pressing buttons and they didn't do anything.

Speaker A
We shouldn't invite them on the podcast.

Speaker B
That's right. And so it turns out you just have to press the whole thing. But people don't realize the whole thing is a button. To everyone who told me to get a Hue tap switch and to just get Hue bulbs also, it's crazy expensive. The Hue tap switch itself is like $50, which already is more than a wimo, like in the wall switch, like an outlet switch. And then I also had to get two bulbs and a hub, and that was like another $70 or something. I'm like out $120 for just the bathroom. When if I was able to just plug, like plug in one of these wimo wall switches that I like, it would have been like $40 the way the future way of the future. So, in conclusion phillips you family products. Not bad, but worse than wemo's after all.

Speaker A
That not bad.

Speaker B
I mean, it works. I mean, I got lights and I can control them from my phone. I could say, hey, dingling, lights in the bathroom. And that works, man.

Speaker A
And here I've just been living by flipping switches in my walls like an animal, like an animal with functioning lights, with no JavaScript involved. Whatsoever.

Speaker B
Yeah, well, lucky you. Anyway, moral of the story, hugh not working out, that great, but I can control my lights with my voice, which is something.

Speaker A
So let's talk about object oriented programming.

Speaker B
Let's transition to actual programming. Chris, you had an article you wanted to discuss this week.

Speaker A
Yeah, I thought it might be fun this week to discuss inheritance and object oriented programming and the various problems with it. And this is something which I don't even remember if we've touched on in previous episodes. I assume that we probably have. But I read this article a week or two ago titled Why Inheritance Never made any sense. And the sort of key point that this article makes is that there really and what you think of as inheritance, like, you inherit, you make a subclass of one class, and in order to, like, specialize it in some way right. Is that there are three different kinds of inheritance going on. And this article actually goes a little bit further than something that I've thought about inheritance for a while. I don't remember where I learned this or who gave me this phrasing initially, but that inheritance conflates implementation reuse with interface reuse. Right. It's useful. Sometimes you want to be able to reuse interfaces, and we have things like protocols for that now. Sometimes you want to be able to reuse implementations, and that is something that we've traditionally done with subclasses with inheritance. And this post goes one step further.

Speaker B
And says, before you move on. So basically you're saying reusing interfaces that's like basically like list golf substitution. You're saying anything that has this type can go in here, whether it's a subclass or whatever.

Speaker A
Yeah.

Speaker B
And then implementation is all about deduplicating code. Those are two separate reasons that we would want a subclass.

Speaker A
Right. Implementation reusing implementations is saying that this thing takes some properties and some methods from this other thing and reuses them.

Speaker B
Right. So an example, this would be like NS array having much subclasses. The implementation reuse is the fact that the thing that builds an NS numerator from the thing is reusable among all NS arrays, but the fact that they're all the same type allows you to reuse them as interfaces in different places.

Speaker A
Right. And I actually have quibbles with NS array and Cocoa's whole mutable subclass problem. I have a blog post about that mutable subclass pattern. Excuse me. And I have a whole blog post about that, which we'll throw in the show notes. We're recording this a little bit late at night, and I'm going to start falling asleep here, so keep an eye on my phrasing here. Let me know when I say something wrong.

Speaker B
I will.

Speaker A
This blog post, which is from Graham someone, graham Lee. Graham Lee goes one step further. In addition to thinking about, like, interface inheritance or Liskov substitution principle and implementation reuse, the first thing that he actually calls out is ontological inheritance, which is like I'm still trying mentally to really tease this apart from implement from interface reuse. But he says that ontological inheritance is about specialization. This thing, like your subclass is a specific variety of this other thing. So example like a football or basketball is a specific variety of a sphere and it takes some properties from sphere, like having a radius diameter, that kind of thing.

Speaker B
Right. It should be noted here that Graham is British and when he says football, he means what we would call soccer ball. We know that American footballs are not spherical.

Speaker A
That makes a lot of sense.

Speaker B
It's late.

Speaker A
I don't know. This is something that I just thought might be interesting to talk about because it's Inheritance, this tool that you learn to use fairly early on in a programming education or programming career if you're doing any sort of object oriented programming whatsoever. And the way that it's classically used in Java and C plus plus and whatever other languages kind of comes with a lot of Pitfalls and it's a hammer and you can use it to kind of solve several different problems, but none of them you solve none of them really well. Or at least when you solve one of them, you come with other problems or other properties that you don't necessarily want.

Speaker B
Right. And you can easily imagine I have, let's say, an NS ordered set and I want it to gain some implementation from NS array and I want it to gain some implementation from NS set, but not necessarily. But I can't subclass from both and I don't want everything from both. So you end up with a situation where and then you also maybe want it to be able to act as an NSRA and act as a set interface wise. But again, you can't subclass twice. You can only subclass once. And so you end up with this thing where you have these four different implementations and interfaces that you want, leaving aside the Ontological Inheritance, because, like you, I don't quite understand how that's different than the other two.

Speaker A
I kind of have an intuition about it, which is like, in addition to saying that a basketball can be used anywhere, that you require a sphere. Right? Yeah, that is right. You're also saying that a football's identity is like a specialization of what a sphere is. And I do think that that's subtly different from interface reuse.

Speaker B
Right. You're kind of describing and saying this is an employee is a specific type of person that's useful for modeling your schema in some abstract sense.

Speaker A
Yeah, I think that's right. But maybe for the purposes of this discussion, we can focus mostly on sort of thinking about implementation reuse versus interface reuse.

Speaker B
Right. I think those are the kind of important ones.

Speaker A
So what are some can we think of places where conflating these two things is bad and brings problems with it?

Speaker B
Yeah, I mean, everywhere, basically. So I think the only times we've ever touched on subclassic and inheritance in this podcast is saying that we just don't really do it. We rely on, as Graham mentions later in the post, composition and delegation for sharing code. And then we rely on protocols and then also protocol default implementations. Protocols for interface, and then also default implementations for implementation sharing.

Speaker A
Right.

Speaker B
And that gets around your you can't have two superclasses problem because you can conform to as many protocols as you.

Speaker A
Want, and those protocols can provide multiple default implementations.

Speaker B
Exactly. And so we kind of got around that by just never inheriting.

Speaker A
Yeah, although we've gotten around that in Swift, really, the Swifty way is kind of not to inherit. Like, if you're programming in Objective C, I think it's still much more common.

Speaker B
Yeah, well, I mean, Objective C just doesn't really have the tools. That's true.

Speaker A
Yeah. I mean, you have protocols. Okay, so maybe let's go over what the things that Swift has that are unique that help you solve this problem. First of all, if you really do want to say that this class is a specialization of some other class, you can inherit, you can subtype. That also means, though, that you have to ensure that you don't violate any of the API contract that that superclass declares. And that is really hard. My complaint about the Coco's Mutable subclass pattern is that one of the things that you can do with an NS array is you can iterate it. And it's not always in all cases, safe to do that with an NS mutable array. Even though in theory you can use a mutable array anywhere. You can use an array.

Speaker B
Right. Because that makes sense.

Speaker A
If the ray is being mutated somewhere else, you can't iterate it and it.

Speaker B
Will crash, I believe.

Speaker A
And it will crash. And that's just not a problem if you are using an Immutable array. And so my argument is that that actually does violate the list gov substitution principle. If you want to reuse like an interface without saying that this type is a specialization of some other type, which I think this really is a pretty common use case, then Swift has protocols and you can adhere something to protocol things that your various APIs can deal entirely in. Protocols don't have to deal with classes at all. And then if you want, like, sharing implementations, as you know, you can use protocol extensions which pull in both interface and implementation, although you can still override that implementation should you need to. Right.

Speaker B
And I forget what it does when two implementations collide.

Speaker A
I think it depends on the order that you've declared the protocol conformance in.

Speaker B
I guess that's good. I maybe just want it not to.

Speaker A
Compile, if that's yeah, I would double check my yeah. Okay. So having done some searching, I found a blog post that I wrote in 2015 about this topic. What happens when you try to conform two protocols, each of which provide an implementation for a method with the same name. In the example that I tried, the compiler refused to compile the code, and I got a clarification later from Doug Greger that says if they are constrained protocol extensions, it uses a partial ordering based on the constraints. Otherwise error. I'm not totally sure exactly what if they're constrained protocol extensions.

Speaker B
So that would be like, if it's array where element is coordinate or whatever.

Speaker A
Then it'll use what does it mean to use a partial ordering based on the constraints?

Speaker B
What are the partial order in contracts? Contracts, like a total order. So a partial order would mean, like, probably like, a more specific one wins unless they're equally specific, in which case, throw your hands up. Who knows?

Speaker A
That seems right. I'm just curious how they're ordering the constraints. Right, but specificity would make sense.

Speaker B
Yeah, specificity is the one. And I mean, I think, like, CSS works based on specificity and like yeah, CSS is terrible. Yeah. Okay.

Speaker A
That's the least argument I've gotten from you on. Well, no, I guess we haven't really had a good argument on here in a long time.

Speaker B
Yeah, it's been a minute. Yeah.

Speaker A
All right, so those are sort of some ways to think about inheritance and what it says, what it doesn't say, and different ways to achieve the same things. In Swift. I think you wanted to dive a little bit into how other languages have.

Speaker B
Yeah, I mean, namely, I want to talk about Java. Okay. Because I think there's object oriented programming as it was originally expressed, and I.

Speaker A
Feel like the small talk argument.

Speaker B
Yeah, the classic small talk argument. Right. But I mean, I think that Java, because it rose to such ascendency that for a while, it was made in 1985. It is probably like, up until ten years ago, it's probably the most widely used object oriented language, maybe with exception with C plus plus, I'm not sure. And it just had such a bad implementation of object oriented programming that I think it sort of poisoned the well for everybody when it came to object oriented programming. So you say, like, object oriented programming, and there are people that really think, like, oh, object oriented programming is about inheritance. And I think one of the arguments that this blog post by Graham is making is that it's not about inheritance. Inheritance is just one of the it's just a tool for sort of handling these types of relationships that we want to express the ontological inheritance, the interface substitution, and also the implementation sharing. And even though this is a tool that we were given to use it, because in Java it was the only tool that you were given to use it, you end up screwing yourself effectively because you have no other. Way to describe anything other than single inheritance, which, no matter what, no matter how good of a programmer you are, you're going to get trapped by it. Absolutely going to happen.

Speaker A
It's not expressive enough to do like to write whatever, to write most complex software. How long has Java had interfaces?

Speaker B
A long time, I think.

Speaker A
So that is one thing to keep. Like Java has had interfaces in addition to inheritance for quite a while.

Speaker B
Right? And so what you end up seeing is you end up seeing every single type has an interface and then type, and that'll be the interface. And then type imple will be the implementation, which will be a concrete version of it. And everything is sort of built around that. And you end up having to do that because you don't know when you're going to need to be able to conform another interface to something and when you won't. And then for code sharing, there's just you have no other choice other than you have no other choice other than subclassing. And so you just end up constantly subclassing after subclassing after subclassing when you're in Java land. And it's absolutely horrible.

Speaker A
That is something you commonly see in people making fun of Java code as like Abstract Interface and abstract Interface simple and concrete base.

Speaker B
They need a factory and they need a builder.

Speaker A
Exactly. All the builders don't forget the build, forgot about the builders.

Speaker B
But if you contrast that with something like Ruby ruby, for all of its flaws, it does give you those tools to share those implementations. So you have like, I think there's something called Def Delegator and Def Delegators. And what that does is it lets you assign a friend to handle a specific method for you so you can delegate to one of your children when a method comes in. Okay, that makes sense. So it basically enables you to do delegation really easily. Did I just scroll over the interesting stuff or should I go back and explain what Def Delegator is?

Speaker A
Yeah, maybe. Wait, I can't even find what am I googling wrong here?

Speaker B
Google ruby, forwardable or defdef? Underscore Delegator module.

Speaker A
Forwardable. I found it. Okay.

Speaker B
Yeah. So the way that this works is okay, so let's say that let's say you're an API error collection. You have an array of errors, right? And you want to be able to be iterable yourself. So you have an array, but you're an object. You have an array as a child, but you also want to be iterable yourself. So one way to do this is you can define your each method in Ruby and that's what allows you to be iterable. And then you can manually call errors each and then pass the block and do all the nonsense you need to do.

Speaker A
Okay?

Speaker B
And so that's when we do it that way, you're manually writing each method that you want to forward over to your child. But with Def Delegators, you just write Def Delegators and you tell it what child? And then you tell it what methods. You want to forward, and it just handles the forwarding for you.

Speaker A
That's nice.

Speaker B
It's really nice. And so this is like an additional tool that you get that enables you to share implementations quickly and easily. And specifically, also, like, you can share only specific messages or forward only specific messages to children. And that's specificity do the whole thing. Yeah.

Speaker A
And that specificity is going to be key to using this in a maintainable way.

Speaker B
Absolutely. And then Ruby doesn't have any kind of interface sense at all, so everything's duck typed, so whatever messages something responds to, that's the type that it is. And so if it pretends, if it quacks like a duck, then I can treat it like a duck. And so you don't even need to worry about the interface sharing, essentially, when you're dealing with Ruby. So there are other ways, other tools that you could have to solve this problem. And then, like, this module forwarding this def delegator thing in Ruby, in Objective C, you have what is it's in the runtime?

Speaker A
Yeah. Objective C has, like, machinery for message forwarding. Like this.

Speaker B
Yeah. Forwarding target for selector.

Speaker A
Yeah, that's it.

Speaker B
Forwarding.

Speaker A
Boy, it's been a while. I was thinking about this while you were talking about Ruby, and yeah, it's been a long time since I've written any code that uses this.

Speaker B
It actually works really great. And if you have a protocol, it works even better because protocols remember, in objects, you were all optional, but you could make it work to where you can forward your protocol and forward all your children, all these messages over to a child of yours. And that was like another tool that you had to share implementations that Ruby just didn't give you. Ruby doesn't give you extensions, which I think are crucial for object oriented programming. Ruby doesn't give you you could argue that multiple inheritance is another approach, which I think C plus plus lets you do multiple inheritance. Right.

Speaker A
C plus plus does come with multiple inheritance. But I think that has mostly been issued by most modern languages. Yeah. Just because of the complexity that can come with it. And the classic what is it, the diamond problem.

Speaker B
Yeah. Which is you have one superclass, two subclasses, and then one subclass that inherits from both of the both of its superclasses.

Speaker A
Right.

Speaker B
How does it know which path to go through for the super calling super?

Speaker A
Especially if both of those intermediate subclasses specialize the same method in some different way. Right?

Speaker B
Yeah, exactly.

Speaker A
And we've talked a little bit about how Swift resolves this with protocol extensions.

Speaker B
Yeah. And I think Swift actually gives you a lot of really nice tools for handling this stuff. So I think basically for everything for your Isa relationship, which I think is Graham's sort of ontological inheritance for Iza, you can use protocols. For your interface sharing, you can use protocols. And then for your implementation sharing, you can use protocols as well. Kind of works really nicely when you think about it.

Speaker A
Yeah.

Speaker B
The only thing Swift doesn't have is true dynamic dispatch. And I will die on this horse. Swift needs to have dynamic dispatch die on this, especially for on this horse.

Speaker A
Or on this hill.

Speaker B
I could die on a horse on a hill. Maybe I'm sitting on the horse and the horse is sitting on a hill.

Speaker A
Why not both?

Speaker B
Why not both?

Speaker A
That's a spirit.

Speaker B
That's right. But yeah, there's that one specific problem where it's like you have a protocol and then a class that conforms to the protocol and depending on what static type you have for that, that determines what version of the implementation is going to be called. There's a really good blog post for this. Here it is. Okay, cool. I found it. It's called the Ghost of Swift Bugs future. Everybody's read this post. It's so good. And this guy Alejandra, I think yeah, Alejandro Salazar lays out this problem really nicely. And you have a protocol, a type that conforms to the protocol, and both the type and the protocol provide an implementation and the implementation that you get depends on what the thing is cast it as. Okay, that's really confusing.

Speaker A
Yeah. Although I remember this being a huge topic of discussion early in the early days of Swift. Has this come up to bite you? I think I've asked you this before. I'm having a flashback to a previous discussion about this. I'm sure that we've talked about this.

Speaker B
It has definitely come up to bite me and it confuses people all the time. Dynamic dispatch is the right approach here and oh, it wasn't Joe Graph, it was Paul Cantrell who linked to it on Twitter, like yesterday. And then he wrote, there's been discussion on Swift's Evolution going around in circles for years about how to make the compiler better, help devs, understand and catch mistakes. And so people know that this is a problem, but it's just I don't know.

Speaker A
Well, I was just going to say, as you know, I haven't really been following Swift Evolution. Has there been any movement or any new discussion on this or is it just kind of a known area of complexity?

Speaker B
I have not seen any movement on it and I think some people think that this is the correct behavior. Yeah, that's the frustrating part.

Speaker A
I mean, in some ways it probably is the I haven't thought about this in a long time, so I'm hesitant to go too far down the road talking about it because I don't have anything intelligent or insightful to say and I'll probably get something wrong.

Speaker B
Okay, I did find what I was looking for. Slava on Twitter says, I think the current behavior definitely counts as a bug, but it's a fair bit of work to fix the bug, is that the subclass should be able to override a protocol requirement witnessed by a default implementation in a conformance on the base class. I mean, I know what some of those words mean, so I would say he's levels on the case.

Speaker A
Makes sense. Can you put that in the show notes, please?

Speaker B
Yeah, sure. Let me grab this for you. He says if you conform to this, like, he should essentially copy that implementation into the body of the implementation into the class. And I mean, I think that's right.

Speaker A
I think that is right. I could see this having some relatively complex runtime implications.

Speaker B
Yeah.

Speaker A
But although I'm not a Swift runtime person, what do I know?

Speaker B
Everything was message sent and it was fine.

Speaker A
Well, yeah, but well, was it fine?

Speaker B
I thought so.

Speaker A
I think that for some of the use cases that they have in mind for Swift, it isn't fine.

Speaker B
That's true. And later in this thread, Slava writes, the language is so complex, we'll never get a complete implementation or even reach consensus on what it means to be complete.

Speaker A
Whoa, that is deep.

Speaker B
Good place to end the episode.

Speaker A
I guess so. I don't know that I have anything more that's useful to add. Well, actually, I take it back. I have two things that I want to add. My thought for this episode just came out of a discussion with a listener a couple of weeks ago via email, who had asked, what's the difference between inheritance and traits and multiple inheritance and protocol extensions and our protocol extensions, multiple inheritance. And I think that we've mostly answered this question. I'll just add that protocol extensions are not multiple inheritance because they don't establish that sort of ontological hierarchy, right. The sort of specialization of types. They come along with some Liskov substitution principle. Like if you want to use something that conforms to a protocol, then by all means use something that conforms to this protocol and gets its implementation from a protocol extension. But it doesn't bring along this ontological inheritance that we talked about, the specialization of identity, almost, that we talked about. Does that make sense?

Speaker B
Yeah, it makes total sense.

Speaker A
And I would just wrap up by saying for some of you, this probably was all nothing new, and that's great for others. Like, the next time you reach to create a subclass to inherit from something, think about what you're trying to do. Are you trying to reuse part of this interface? Is a protocol a better choice? Are you trying to reuse an implementation or just part of an implementation? Is a protocol with an extension the correct choice? Are you really trying to specialize this type? And in that case, maybe inheritance is the right choice?

Speaker B
Yeah, very reasonable. That seems like a good overview of everything we talked about. As always, Chris, it was super fun. And as always, Patreons, you're the best.

Speaker A
Yeah, as always, thank you so much for your support. We really appreciate it. Our editor Joe really appreciates it. And we'll talk to you next week.

Speaker B
Later, Chris.

Speaker A
Bye, sirish.


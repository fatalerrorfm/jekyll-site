Speaker A
Hey, everyone. Welcome to Fatal Error. I'm Chris. And I'm, sirous. And this week we have a special guest. Calvin, you want to introduce yourself? Yeah, I'm Kelvin and sometimes we go by the name Taylor Swift on the Swift Evolution list. And yeah, so this week we thought we would chat a little bit about Kelvin's work because you have a couple interesting guest hub repos, but mainly about Swift Evolution and maybe some of the changes coming to that process for Swift Five, which I don't totally understand just yet. Swift five already. Chris posted something in the Async thread that was like, this may not come until Swift seven or eight. And it was just like, wow, we are really already talking about that. I'm barely even paying attention to the Async thread. That thing got, like, 100 messages in a day. Yeah, people really psyched about it. What's your general thought about the Async and the actor stuff? I mean, it's definitely something important to have. I don't really have the attention span to read through that tire through Ed, but I'm glad that's being taken really seriously, though. It seems like there's a lot of effort going into that. Yeah, I read Chris Latner's sort of proposal and the draft of a concurrency manifesto, but I haven't read the Swift Evolution thread about it. I also don't have the patience or the free time. I trust that they'll get it right, because there's people who know a lot more about Async stuff than I do. Yeah, there are people who've designed languages before working on this. Yeah, I haven't. Cool. So I guess before we get started, Kelvin, is there anything you want to tell us about your background and where you come from and how you approach thinking about this stuff and how you got into Swift in the first place? This is going to sound kind of, like, funny, but I actually got programming in general in Swift because of Kylie Klaus, and if you don't know who she is, she's a model and entrepreneur. She runs code with classy, and like, a couple of years back, she went to the Apple Developer Conference thing and she instagrammed about this new language called Swift. And since I'm also a big Taylor Swift fan, that was really funny. And first it was like a meme. Then I was like, I'm going to check this out. And learning how to code would be really fun and stuff, so I'm kind of, like, self taught in that way. I didn't seriously start learning Swift until about a year or two ago. I've written a lot of code in the meantime. Nice. And you're in college. Are you majoring in computer science? Yeah, I am. Computer engineering. Nice. Cool. What languages do you use, like, for your schoolwork? That would be mostly C and assembly at the moment. Wow. C plus plus also is in the mix. Swift hasn't really caught on at the college level much yet. Yeah, I feel like it's too new. Yeah, I think that'll take some time. They don't really think it's going to be big enough in the near future to justify replacing C as the default language, even though there's been like a few. I've read some blog posts about professors that are starting to introduce with Swift, but not a lot, right? And I guess they've seen Java try to come in and take over, they've seen Python try to come in and take over and none of them have, really. Java and Python I think are pretty popular now. The main thing with Swift is that they don't see Apple themselves using it. Interesting. By Last News, only one app like the Calculator app was using Swift. Actually, everything is still objective C, right? So the thing I heard was that the new editor in Xcode is all written in Swift. I heard that at WWC, but I don't know, I don't know if I have a source for it. I can try to look that up. Yeah, I don't know about that. I think they're starting to roll this out. Right? Once we have abi stability, hopefully post Swift Five, I think we'll start seeing more adoption within Apple. Post swift. Six. Yeah. And so you found this Swift programming language and then you kind of also got involved with the design and the discussion about the language internals on the Swift Evolution mailing list, which I have to talk about a little bit. How did you end up putting yourself out there on that list and saying, hey, let's talk about this stuff and let's get into the nitty gritty? I mean, it took me a long time to really start to involve in the actual language design because I always thought that was something that was far away or that's not something I saw myself being involved in. And I guess when I first got introduced to that was back in the Swift theory days when Swift was really unstable, and that's when it would crash like every 15 minutes basically on protocol or whatever. So around December, I think there was some kind of big drive to find all these crashes and fix them. It was called like real compilers Never Crash or something like that. And I don't know how I found that to begin with, but I do know I remember finding Slava's Twitter and he was asking people if they've seen bugs or crashes in the compiler and to report them on Twitter. And since I'm more active on Twitter than a mailing list, I don't really have a lot of experience on mailing lists, so I think Twitter was more accessible for me considering I already had a stand account there. And I started just first DMing sava, just test cases that were crashing and there were maybe ten of them overall. And then eventually it was to the point where maybe you should bring this up on the Swift users mailing list or the Jira tracker. And then I think once I got more comfortable talking on a mailing list because that's like a completely different format to Twitter, that's when I started thinking about, hey, this is actually a community driven process. You can propose changes to slip and it's not just like a top down completely system there. And when you think about stuff like pointers, which is what I'm pushing right now, people might have the assumption that, yeah, that's just like, set in stone and for whatever reason, that's how it is. But it turns out like, that was actually just like a neglected part of Swift that needs to be hashed out again. Right, so you proposed something called improved pointers. I see white four and put that in the show notes. I only barely know about the pointer system in Swift, so I don't actually understand what this is changing. Can you give me a quick rundown of someone who, like, I understand what a pointer is and I barely understand how the system works in Swift, but I'm curious to know what this changes and how it makes it sort of better. There's really like, two parts to the proposal. The first half is kind of just like housekeeping work, which is methods that have inconsistent naming or they have bad argument labels or whatever like that. And then the other half is kind of rounding out the API because there's like a lot of missing methods right now. For example, buffer pointers, you can't really do much with them. And then with raw pointers, you have some of them, like raw pointers support de allocate. So do plain unsafe mutable pointer. But the unsafe pointer, the immutable version, doesn't have a de allocate, which was the subject of a bug, I think, while back, and that needed to be fixed. And there's also just the allocators which take capacity arguments and that's actually like a safety bug. So that had to be reworked. Interesting. Kind of just like a lot of built up stuff. Yeah. I read over the proposal. It seemed like you proposed a good number of changes just to make things more consistent in terms of naming and parameter types and availability of features across the different unsafe pointer types. Yeah, I think until now, basically new features to pointers were basically added one by one based on what the standard library needed. Initialized two count has this random default argument of one, but then not a lot of other methods which also take. It would have that just because the standard library uses that method with a default value of one a lot. So they just folded that in there? Yeah. Is there stuff that's like internal or private in the standard library that you're like, wow, this really should just be public? Well, actually the standard library doesn't have anything that's public. I mean, five bit or internal five bit or five bit that's just for transparency reasons. It has something to do with inlining and the fact that you have the cross module optimization with the standard library, though, you have to write it like this weird way where you use underscore methods to signify, like, non visibility and stuff like that. Got you. Interesting. Cool. So what was your motivation for, or I guess not motivation for. What were you working on that caused you to run across these consistency issues in the unsafe pointers API? Well, I have PNG library. I do a lot of stuff that works for image processing and stuff. And for that to be you use unsafe buffer pointer a lot, but you can't really actually create or allocate an unsafe buffer pointer. You have to do the whole dance around base suggests and all of that. So it was just like, this is really inconvenient. Why don't they have allocators? Or why can't you just deallocate a buffer pointer? Then, like, I proposed that originally it was just for allocate and deallocate, but then people brought up that, hey, the memory state functions are also a mess. So I figured I tackled that at the same time. Right. And it clearly was a good idea. It's into the Swift Evolution repo, and it's awaiting review. Right now? Yeah, right now I'm still iterating on it with Angie Check. And it's taken a while because there's been like four versions of the thing with a slightly different proposed API. Right now, we're trying to deal with the fact that we want to support partial initialization, so that's when you want to transfer the contents of one buffer into another, and that can just like, leaving part of it uninitialized. So you want to be able to provide somewhat safe interface for that. Yeah. So what's your experience? How's your experience been with the Swift Evolution process so far? Is this the first proposal that you've actually submitted? Yeah, it's the first one. And how's it gone? Because I've never personally submitted any evolution proposals, so I'm just really curious to hear what that's like. It took a lot longer than I expected it to. I thought this was going to be something that would take like two weeks, a month at tops. It wound up taking a lot of iterating, and that's probably a good thing because when we got to the fourth version, by then we actually caught a lot of unforeseen issues in the first version that we might not have noticed otherwise. And getting feedback from a whole bunch of different people is also helpful in that. And also there's the implementation requirement. That's new. And swift. Swift five. And there's some controversy around that. Yeah, I definitely want to talk to you about that. Yeah, I'm kind of on the fence about that. Some people hate it, some people like it. So just for background, because I haven't been following this too closely, but I know there's some controversy, this means that before you actually get an official review period for your proposal, you have to have an implementation in addition to the Swift Evolution pull request. Right? Yeah. Well, I think part of it is that it was kind of really poorly messaged. They're just kind of changing the state machine for how accepting a pull request works. They obviously don't want people to go out and write an implementation and then pitch to everybody and everybody says, yeah, this isn't the right time, or we don't like this, or whatever, and then all that work has gone to waste. So they're actually doing a pre review, which functions a lot like review does today. Yeah, you see that's the main issue that I have with it is that it doesn't really change anything, it just adds a second review after the fact it's already implemented, so this pre review thing is really becoming the actual review and then there's just another review after that that's more official. You've gone to the trouble of making an implementation, probably it's going to get accepted at that point. It's just a matter of I think what they wanted to avoid was like, oh, we think this proposal is a good idea, we have no idea when we'll get a chance to implement it, so we're going to accept it and leave it in this accepted state for years. Yeah, I think that was like a big problem in Swift three reduced the backlog. Right, but at the cost that new ideas would never even get into Swift Evolution in the first place. Whereas before, if it didn't require an implementation, at least you would have that idea on the shelf and then people won't forget about it. Right. What happens now if for something like your proposal, Kelvin or Sirous, the proposal that you made around for Guard Catch or like, if I wanted to submit a proposal, I have no idea how to implement something in how to implement a compiler feature. Right, yeah. I know that the Swift team or some members of the Swift team have said that if there's a good proposal coming up, they'll help find someone to implement it or the community will step up somehow. Does anyone have a sense of how well that's actually going to work yet, do you think? I mean, I'm skeptical about that because I feel like there's only like 20 or so people actually know the compiler and most of them work for Apple, and it's my understanding that they're already overloaded with just technical depth and just fixing issues in the compiler and existing work. So I can't really picture a core team member actually having the time or the interest in implementing these just proposed ideas that show up on the list. So now basically, getting something into the compiler would just consist of trying to persuade at least one person on the core team to implement this feature for you, and instead of getting approval from the sub community at large through review. Now it's just trying to sell one person on that idea and then yeah, there's definitely a lot more persuading that has to happen with this new model. Before it was persuading the community, now it's just trying to sell it to one person. Right. On my pull request for the Guard Catch proposal, somebody commented and wrote to be clear, proposals need an implementation, but it's not important who implements it. The court team has also implied that they might help pair proposal authors with implementers, so I wouldn't worry about that part. So it kind of sounds like if the proposal is good enough and if it's going in, somebody will do it. Like if it's just something they didn't think of or if it's a community proposal for something the core team wants to do anyway. But yeah, there's definitely a lot more persuading is one way to put it. I think another way to think about it is like it reflects the reality a little bit better of the fact that there are only 20 people, as you said, that can implement a feature in the compiler. So if you want to do something, like you either have to learn the compiler yourself and do the work for free or convince one of those people that it's a good idea and that they should carve out time to make that work. Yeah, it's a high bar, which is rough. Yeah. Again, my concern is just like ideas might get lost in the process because there's like a really good draft, like a document for fixed size arrays a while back and I really like that. But obviously to implement that would require going into the compiler itself because it's like a language magic feature. It's not like something you can just do in the standard library or in foundation that's kind of at risk of just being lost forever. That would be like a really big disappointment. Yeah. What is a fixed size array? Can you not just implement it at the runtime level or does it have to be at the compile time levels? Fixed size arrays. There's been a lot of discussion over the name, what exactly it means. I think people can agree that mostly they're stack allocated and they live inside the structure. So it's like in C where you declare an array with N length. So that's why some people call them just like extended pupils or contiguous variables or something like that. So instead of like if you wanted to store an IPV six adjust, you could have an array with eight U and 16s, but putting them in an array, that would store them in a heap and that's not really optimal. So instead you would want them on the stack. Like right now you would write a tuple and then you would type you in 16 eight times, but that's kind of like stupid and you can't iterate through that because you can't subscript into a tuple. You can imagine that in addition to allocating on the stack versus the heap, having a fixed size that's known at compile time could allow some better type checker tricks. Yeah, right. So you can shift some of the things that will trap at runtime now maybe into compiler or compile time errors. Yeah, that makes sense. It's also good for lookup tables because if you want to convert a digit to hex and see, you would just have an array in the function body that's just like ABCDEF and then all the digits and then you just subscript into that. But you can't really do that in Swift because that lookup table would live in the heap and it wouldn't really be efficient. That makes sense. Useful. Yeah. I can think of a lot of cases in which that's useful. If you ever tried like port C code too Swift, you'll get hung up on fixed size arrays real quick. Got you. There are a number of applications in cryptography algorithms too. Yeah, I was thinking about hashing and stuff where you know that the array of things that comes out is always going to be this exact size and be fast. Yeah. Because yeah, the way I do that stuff right now is you just have an array of uint eight or whatever it is and it's just yeah, that's right. So as it stands now, whoever's proposing the fixed size array has to in addition to pitching it to the Swift Evolution list and getting people to generally accept it, has to find someone who can actually implement it. Yeah. And again, that set of people I feel like is pretty small. So the likelihood of that happening, I don't know. Yeah, I guess we'll see. It's still early days, so we're all just kind of speculating. Well, and if it sucks, I think they'll change it. I guess. That's a good point too. The team so far seems like flexible and receptive to input from the community, so maybe we're worrying a lot here about really nothing. Yeah, I mean, on the other hand, I feel less like I could propose something to Swift Evolution today than two months ago. Right. And I think that part of it is intentional. I think there was a lot of discussion and a lot of kind of consternation about things that are on the Swift Evolution maintenance, about things that can't happen anytime soon because of priorities and because of resource constraints, of just there's only so many people that can write this code. And so I think part of the goal has to be to tamp down some of that Swift Evolution energy. I don't know how most people would propose things on Swift Evolution list. I don't know if people right now would just write something up and just send it on the list for the point of proposal. It was actually like a long time in the making. I was talking to people on the core team and on the Swift team for weeks before it was actually ever sent on the mailing list. Kind of just like writing that thing up. I was talking like, Harvard haskins a lot with that. So by the time it actually showed up, it had already been through sets of eyes. Yeah, that's what I did with my Guard Catch proposal is I basically had a bunch of friends look at it and we all had this big discussion in Slack about how should this work? What about this case? What about that case? And so we had gone through, I think, like five or six revisions, adding a bunch of different edge cases, adding a bunch of alternatives considered and reasoning for why we didn't think that was good. And then before it ever even hit the mailing list as a pitch. Yeah, basically having a few good developer mutuals on Twitter or something, it's good be able to bounce stuff off of them like that because on a mailing list it's so asynchronous that you can't really have real time discussion about it or hit on a lot of these small topics. So do you think that'll change with, I guess there's some discussion or a plan to move some of this activity from these mailing lists to a discourse forum somewhere online and I forget, I guess, exactly if that's definitely happening or if that's just something that they're thinking about. I've heard the word discourse come up a lot on the list for months now. I don't know if it's actually going to happen soon, but then again, I've also never actually used discourse. I don't really know what that would be like. It's hard to be worse than a mailing list. I've been on that thing for a couple of months now. I still don't know how to use it properly. Yeah, it's totally miserable, the mailing list, and it's really hard to spin off new threads and stuff. I use Discourse. A friend of mine set one up and it's really nice and you can take any message and click Start new thread and it will create a new thread from that message and then people can kind of spin off discussions like that and it would be better searchable, it would be better linkable. All that stuff would just be so much better. Is this move to Discourse definitely happening, Sirush? Do you know or is it just an idea at this point? They said they were definitely going to move to Discourse and then they wanted to do it in this kind of like swift four time frame, but because of reasons and everything getting pushed around, they didn't actually make it. And so Ted Kremenk made a post. It was like two, three weeks ago. We'll try to find it for the show notes where he said basically we dropped the ball in Discourse, but we're definitely doing it. This is a threat to kick off any discussion you want to have about it. We're going to auto import everything. We're going to try to tag things correctly, and if you can put stuff in brackets, that'll help us tag things. So I do think it's going to happen. It's just a matter of, like, this is a ton of data, it's got to get moved over from one system to another. But I think eventually it's going to be much better and I think it'll be easier to read. The quotes will be nicer. I'm just really looking forward to it. Yeah. Maybe for the rest of this episode. If we want to switch topics a little bit, I was kind of curious, Kelvin, to ask about the Swift work that you have on GitHub. You have your PNG library and programmatic Noise Generation Library, and they're written in Pure Swift with no dependency on foundation, right? Yeah. And I was curious, what's your motivation or interest in this stuff? Why? Pure swift without foundation dependencies. You want to tell us a little bit about that? I mean, I'm interested in game development, so I've been just like, over time trying to build these building blocks basically for stuff like CGI, game development, image processing, procedural noise is something that's important for that. And right now that's on the Apple end that's being covered by thing. I don't remember what the framework is, but we didn't really have like a Lib noise equivalent or Swift or like a noise Rs like they have in Rust. So that was just like me implementing a Pure Swift version of hurling noise, royalty noise, all those basic foundational building blocks. If you do anything like 3D or CGI, those are basically 90% of what you do with procedural noises. Everything else comes from perlin and oily. So that was like a big low hanging fruit to say. Cool. Yeah. So these are written in when you say Pure Swift, you mean no foundation at all? Yeah, no foundation. And a few of them employ G, Lib C or Darwin, which is an issue because a lot of times I forget to import Darwin. So then it's not until like a while later when someone says, hey, this doesn't build on Mac OS X. Which is why I was kind of like proposing a unified Lib C import on the thread. Yeah. So Swift obviously doesn't have any concepts of an image natively, and foundation doesn't either. So what this has to do is it basically generates the thing and then writes it to a file. And then you could view that file with something else. Right. It doesn't write to a file, actually. That's just in the testing framework. The noise library itself is abstract. It doesn't even make a buffer. You fade a noise object noise structure, and then you sample the noise at XY coordinates, though you can really do whatever with it. You can distort it, do FDMS, and so ultimately it's like an array of bytes under hood, there's no array of bytes that creates it's like 2D or 3D function. You evaluate it, you sample it at points. Like the noise library does have a built in sampler for you to create a byte array. But if you want something more flexible, you can just sample the function directly. Interesting. That's cool. That's why it's called procedural noise because it has infinite resolution. I got you. So this isn't actually dependent on PNGs at all? No, that's just like viewing the noise. Got you. Okay. Weird. Cool. Okay, and then so the other library that you work on is Max PNG. Similar situation. Pure swift, no foundation. It's not exactly Pure Swift because it has one dependency on Zlib. Once upon a time there was a Pure Swift inflate implementation of the Z inflate algorithm. I don't think that builds on Swift anymore because whoever was maintaining it forgot about it. It was part of like the Swiftgl SGL whatever library. It was David Turnbull who wrote it. So yeah, that was actually like a Pure Swift PNG decoder, but it didn't support encoding and again, it didn't build. So like, I kind of like voted replacement for that. And it handles more cases too. It basically works like the entire PNG test suite. Nice. And it also validates too. Nice. So these are obviously since they are not dependent on foundation, they don't need Linux Foundation to be implemented completely at all. So when you write this stuff, do you work in Xcode or Mac environment, or do you work in a Linux environment with some other editor? I work in a Linux environment. Nice. I use Adam for everything, which is kind of why sometimes on the mailing list I talk about whether or not this is something that can be supported with syntax highlighting or general because people tend to be very Xcode centric on there, which I don't think is completely a good thing. Yeah, I just moved my Swift on server project from only running in Linux and needing TextMate to edit it to finally also compiling and running on the Mac so that I can work in Xcode and there's upsides and downsides to both. It's really nice that when I was working in Linux that I knew it would work the exact same in all the Linuxes. Whereas now when I run it locally, it's going to be different than when it runs, sort of when it's deployed on Heroku. But having autocomplete and stuff is really nice. I don't know if you have the Autocomplete plugins for nice. I don't think it has them, so not really. Okay. I've heard they exist, but I've never looked into it, so maybe they don't. I mean, I basically wrote the syntax highlighter, so there's probably like three Swift packages just like foil language at all. There's a Swift Linter, so that's a good thing, but I don't think it's autocomplete. Got you. That makes sense. Cool. Kelvin, thanks for. Coming on to Fatal Error. If our listeners want to find you on the Internet, or if there's any way you want them to get in touch with you, if they have questions or anything, if you want to share, like email, GitHub, Twitter or whatever, is there anywhere people should try to reach you? I mean, my GitHub is Calvin 13 and I have four or five libraries on there, so if you have something like, specific to a library, you can just comment on there, open an issue, I'm always welcome to that. Cool. Yeah, this has been a lot of fun. Thanks so much, Kelvin. We'll throw links for your GitHub in the show notes and to all our listeners, thanks for listening and serous. I'll talk to you next week. Yeah, thanks. Cool. Talk soon, Chris. Bye.


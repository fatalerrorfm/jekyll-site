Speaker A
How's it going?

Speaker B
Not bad. I'm reading about Avengers Infinity Ward theories on the Internet.

Speaker A
Avengers infinity.

Speaker B
Ward.

Speaker A
This sounds like the comic book movie thing.

Speaker B
It sure is a comic book movie thing.

Speaker A
I see.

Speaker B
Yeah. What's up with you?

Speaker A
Not a whole lot.

Speaker B
What what were you doing? Just hanging out or oh, we were.

Speaker A
Watching a city council meeting.

Speaker B
Very exciting.

Speaker A
And drinking and talking about it. What's new with you?

Speaker B
Not much. I was in Mexico all weekend. That was really fun.

Speaker A
Oh, that's right. Yeah. How was Mexico?

Speaker B
Mexico was cool. We were kind of in Quintana Rue, which is like if you've heard of, like, Tulum or obviously playado Carmen and Cancun. You've also probably heard of those. That's where we were. Cool. They're all very close together, so you can actually go to one and visit the others.

Speaker A
I'll bet it's warm there.

Speaker B
Yes, it was very warm until it rained the last day we were there. That crazy weather day that everybody experienced on Sunday. Yeah, it was raining down there, but then after the rain, it was very cool.

Speaker A
It's been like, snowing here. It might as well be December.

Speaker B
Yeah. That's crazy.

Speaker A
It's miserable.

Speaker B
Yeah.

Speaker A
There are a lot of people who I know in this Avengers movie.

Speaker B
Yeah. They've kind of been building up to it for, like, a decade.

Speaker A
Really?

Speaker B
Yeah, something like 19 movies or something.

Speaker A
Wow. Really?

Speaker B
Yeah, it's been a lot of Marvel movies.

Speaker A
Yeah, that's a lot.

Speaker B
Yeah. So it comes out, like end of this month, I think. I guess it comes out like two weeks, april 24. One week.

Speaker A
That is pretty soon here. Yeah, exactly. A week.

Speaker B
Yeah. So that'll be fun to see.

Speaker A
Wait, it says in the US. On April 27.

Speaker B
Yeah, but it looks like it's like 07:00 p.m. On the 26th are the first showings, at least in New York. I don't know about Ann Arbor.

Speaker A
Oh, I'm just looking at lake Wikipedia.

Speaker B
Maybe I'll do like a Friday matinee situation for this, when you have the flexibility.

Speaker A
That's true.

Speaker B
I did learn one really cool thing about Cancun. So I went there and I looked at my phone when I landed, and the time changed because it's in a different time zone. Right, okay. And it's like, pretty much like I met two of my friends from Houston. They're obviously in Central Time, and I kind of think of Cancun as being basically south of Houston, not south of New York. So why would it be in Eastern Time? It's obviously in Central Time and my phone changed. All these assumptions seem to be bearing out.

Speaker A
Okay.

Speaker B
And then I was reading Dave DeLong's, yourcalendrical fallacy.com website, and I was reading and one of the examples he gives for I think it's like a place that has changed its time zone, he said Cancun went from being Central Time to Eastern Time. I read that and I was like, Wait a second. So did they change back because my phone definitely changed time zones, like my.

Speaker A
Clock definitely changed time zones, but different Daylight Saving Time rules.

Speaker B
Exactly. Didn't figure that out for a minute, so I was like, oh, maybe they changed it back. But then I could only see news articles for them changing to Eastern, but not back from Eastern, which I thought was weird. And then I did a little more digging and I learned that they're on Eastern Standard Time, not Eastern Daylight Time. So right now we're on Daylight Savings time, but they're still on Eastern Standard Time. So in the winter it's the same time zone as the Eastern, but in the summer it's the same time zone as Central.

Speaker A
Do they observe Daylight Saving time at all?

Speaker B
No, nothing at all.

Speaker A
Okay. Because you remember several years ago now, congress changed our Daylight Savings Time rules. So we start Daylight Savings time now earlier in the year and end later in the year than we used to. And I know it's possible we're now on a different DST schedule than a lot everybody European countries, right? So for a little while, we're only off from the UK by 4 hours, and then we go back to being different by 5 hours.

Speaker B
And then at the end of the year, it becomes 6 hours and then goes back to five, I think.

Speaker A
Right?

Speaker B
Yeah. So Mexico as a whole does observe DST, but two states, Quintana Rue, which is where all that stuff is, the Tulum and Platal, carmena and Cozumel and Cancun and Sonora, which is kind of directly south of Arizona. So those two states don't observe DST. Well, that makes sense because Arizona also doesn't observe DST, so I bet it's good for trade.

Speaker A
That makes sense. Yeah. I think that's the motivation to try to be in the Eastern Time zone, right?

Speaker B
Yeah, I think so. And I think there's a lot of visitors from the Eastern Time zone, so they want to be on the right thing for them.

Speaker A
Yeah, I could see that.

Speaker B
Yeah. I'm all for permanent daylight savings time.

Speaker A
Yeah, I am too. Honestly, I think that don't call it daylight saving, just change our whatever you want to do. I want to be GMT minus four, not GMT minus five.

Speaker B
Right.

Speaker A
I want to be Eastern Daylight Time all the time is what I'm trying to say.

Speaker B
Yeah, that's what I want to because I don't want to be Standard Time all the time because that actually is pretty horrible in the summer. But daylight being on Daylight Savings Time wouldn't be that bad in the winter, I don't think, because you don't have that much daylight anyway.

Speaker A
Right? Yeah. It's already just miserable.

Speaker B
Yeah. So just endure the misery in the winter and don't endure the misery of changing time zones.

Speaker A
Yeah, I tend to agree.

Speaker B
Yeah. Savings time, man. Pretty complicated stuff.

Speaker A
Yeah. Did you see the discussion a while ago or sometime or late? Late last week? There was a stack overflow thread that was floating around where one of the iOS date APIs, or maybe, like, localized date formatter APIs would, in a certain time zone for a certain date, would just return. Nil wow. It turned out to be correct. It was somewhere in Brazil. I think that just the way that Brazil implements, like the day late savings, time changeover, and on some days, some of the days that it's allowed to happen, it's possible for there to be just times that do not exist on that day. And so if you happen to be trying to format one of those times, that's just not a time that can possibly exist. And so the date formatter returns. Nil which can be surprising. I'll try to find this. Where did I post this? I'll try to find the thread.

Speaker B
So here it says, Brazil performs its DST leap forward transition at midnight, which means that 11:59. P.m is followed by 01:00 A.m.. So on that date, if you tried to parse a date that was twelve five, that would not work.

Speaker A
Yeah, it was something like that. I put in one of oh, here we go. Okay.

Speaker B
Did you know there are some places that are GMT plus 14?

Speaker A
Yeah. There's like, somewhere in the middle of the Pacific Ocean right.

Speaker B
Because they would rather be with Australia and New Zealand time zones rather than with American time zones.

Speaker A
Yeah.

Speaker B
Even though you would never expect there to be anything more than plus twelve because absolutely.

Speaker A
Do you remember there was a Tweet going around a while ago, or someone was like, I was at Pub Trivia and the trivia host asked how many time zones are there? And said that the answer was 24, which is just like, oh, honey.

Speaker B
Yeah, this is extremely wrong. I think we maybe talked about that on this show.

Speaker A
That sounds like something that would have happened. Yeah, I'll allow it.

Speaker B
Yeah, let's see if we can dig that up. Did you find the stacker flow thing?

Speaker A
Yeah, I did. It looks like so it was just trying to format the date 1120, like month, year, year, year.

Speaker B
Right.

Speaker A
And trying to format that in a localized manner in this specific time zone returns. Nil wow. Oh, and the other complicating factor was that it worked fine on iOS 11.0, not on 11.2.6.

Speaker B
Interesting.

Speaker A
I forget the details here, and I'm not going to try to parse the stack overflow thread on the air, but the gist is that Brazil recently changed something and yeah. Like midnight on the first day of the month doesn't exist. Right.

Speaker B
Yeah. That's crazy.

Speaker A
Yeah, it's definitely a great example of the just, like correct, but very surprising things that happen when you're working with dates.

Speaker B
Yeah, I have a couple of starred stack overflow things, and there's some weird ones out there. There's one where on December 2, 1847, if you initialize a date and then move forward by 1 second it moves you forward by 75 seconds. Because there was something we did to the calendar back then to line it up with some other thing back in 1847, and those 75 seconds don't technically exist. We just leapt forward.

Speaker A
That's hilarious.

Speaker B
The moral of the story that I took from this was like, if you think the NSDA is doing something weird, it's probably doing the right thing. And the calendar that it's modeling is what's weird.

Speaker A
That is?

Speaker B
Yeah, like trust or trust NS calendar.

Speaker A
Right. It's doing the right thing. It's just that in this specific time zone, something changed in iOS 11.2, and now that time doesn't exist anymore.

Speaker B
Yeah. It's gone. Yeah, it's pretty nuts. I can imagine trying to track that bug down, too, where you're just like, this shit should never happen.

Speaker A
Oh, yeah. Definitely assume that just anything can happen in date math.

Speaker B
Yeah, that's right. So should we move on to, like, a main topic?

Speaker A
Yeah, I feel like we should. I think last week or the last time we recorded, you had mentioned a topic which I think you called Swift Strings and things that are hard to hold. Is that still something you want to talk about?

Speaker B
It is still something I want to talk about.

Speaker A
Is it something you want to talk about today?

Speaker B
I think so, yeah.

Speaker A
Excellent.

Speaker B
Yeah. So essentially what happened was we were in Slack a couple of weeks ago, and somebody asked they were doing, like, interview practice questions, right. And they're like, you know how those things are. They're like, oh, do perform this operation in this time complexity. For example. So they'll say, grab the first 20 items of this array sorted, but do it in O of N, for example.

Speaker A
And these are things that appear, like, notes that appear in the documentation for whatever method we're talking about.

Speaker B
Yeah. In some cases, like, the time complex o of N or o of one or whatever will show up in the documentation. In other cases, you kind of have to know what you're doing to understand. Exactly.

Speaker A
Sorry, I lost track of what you're saying. I thought that you had mentioned some of the Swift Collection APIs, the protocols dictate via documentation what the complexity of certain operations is supposed to be.

Speaker B
That's right. That's definitely right. So what this question that this person was trying to solve was asking was update a character at an arbitrary index in the string in o of one time. Okay, so what that means is if you have the string, let's say house, and you want to change the third character to a hyphen, you should be able to change it to ho hyphen se in o of one time, that is, without iterating, the array.

Speaker A
And what was the context for this discussion, again? Because for various Unicode related reasons, that is not possible in Swift.

Speaker B
Exactly. That was essentially like, what the conclusion that we kind of came to?

Speaker A
Yeah.

Speaker B
So what I wanted to do is I wanted to kind of talk about why it's not possible, what makes string so complex, and whether or not Swift's string has a good model or not.

Speaker A
Okay. Yeah. This sounds like an interesting topic, although I think Swift strings have kind of been litigated to death. But, sure, let's go for it.

Speaker B
But I maybe have a new take on it, which is that they're actually good instead of bad.

Speaker A
I think that's the correct take.

Speaker B
Well, they're so hard to hold. As you mentioned earlier, the topic is, like, things that are hard to hold. Those strings are really hard to work with.

Speaker A
How so?

Speaker B
Well, let's get there. Let's talk first about this problem of trying to get a third character in an arbitrary string to a new character. Right.

Speaker A
What do you mean by character?

Speaker B
That's right. There's a really good tweet that Joe Groff retweeted a couple of months ago that was, like, a great interview question is, how do I get the length of a string? And it doesn't even really matter what you answer as long as where the correct answer, I think, was like, what do you mean by string? And what do you mean by length?

Speaker A
Exactly?

Speaker B
Yeah. So what do you mean by character? Is a very interesting question. Obviously, some languages treat them as fixed width. Maybe that's not obvious. Yeah. So some languages treat them as fixed width. So famously, NS string is fixed width at 16 bits per character. Per character. They're utf 16 strings, which means that if you want the fifth character of a string, you can just go to the offset at 80. Right. 16 bits times five characters. You just jump to offset 80, and you can instantly find that character.

Speaker A
So you can do this operation in order of one time in constant time on NS string.

Speaker B
That's right.

Speaker A
You can also do it in constant time with, like, AC string, which is an array of characters, an array of bytes. Right.

Speaker B
Yeah.

Speaker A
And in many other languages that follow the sort of C or C inspired model for dealing with a string, where a quote unquote string is a buffer of characters and each character is a constant number of bytes.

Speaker B
Right. The problem with modeling it that way is that if you only have 16 bits, then two to the 16th is around 65,000, and you can only represent 65,000 different characters. Right.

Speaker A
Yeah. I mean, there are a few different problems with modeling it that way, but yeah, that is one of them.

Speaker B
Yeah. To me, it's the most straightforward problem, which is you just don't have enough letters to represent the letters that you like. You don't have enough characters to represent every letter you want to represent.

Speaker A
You don't have enough characters to represent all the possible characters that you may want to represent. Dealing with languages that aren't English. Right. Also, if you just store everything as utf 16 like you're wasting or potentially wasting storage space. Wait, is that true?

Speaker B
I think it is, because what Swift ends up doing is if it's an eight bit character, like the letter A in the Latin alphabet, it will store that as eight bits. And then if the next letter needs to be 13 bits or sorry, 32 bits, for whatever reason, it will put that right next to it. And the next letter, again, could be eight bits. And so it will pack them very tightly.

Speaker A
Yeah.

Speaker B
Now, what that is, is that's basically variable width encoding, which means that you can't now jump to the 80th bit to get the fifth character, because those previous characters may not each have the same width. They may be 816, 32 bits wide. I think some could be actually 24 bits. It's very crazy. And so you end up with basically a situation where you don't know how to jump to that bit that you want.

Speaker A
Right, well, and so complicating there's a complicating factor, too, which is so far, we've assumed that a character is, or what we think of as a character is a single entity which takes eight or 16 or 32 bits.

Speaker B
Right.

Speaker A
What you think but what we think of as a character, if you're, like writing, might be something like an E with an accent over it. Right. And that's something that can be represented in Unicode by combining two characters, each of which is, I think in this case, each of which is eight bits. You might end up with a buffer that has two of what would look like a character in a language like C, like an E and then binding Accent, or maybe vice versa. I forgot what order they go in.

Speaker B
And then the accent.

Speaker A
Okay. Yeah. So if you were to just look at the string and replace a character by index just the way that you would trivially want to do that in C, you'll end up being off by one in a string that contains a character that's actually composed of these two different bytes.

Speaker B
Right. So what Swift does to handle that is basically every character is one character on screen. Yeah. We haven't even talked about emoji yet either, which can be modified by gender modifiers and skin tone modifiers with a thumbs up and then a medium skin tone modifier, which is two Unicode code points that are totally separate but get rendered as one. And Swift correctly handles that. When you ask how many characters are in that string, it'll say one character instead of two characters. Other languages don't do that.

Speaker A
Right, yeah.

Speaker B
And earlier versions of Swift also didn't do that.

Speaker A
Right, yeah. This is something that's undergone a lot of revision. Definitely. In Swift Three, I forget exactly when a lot of this revision happened, if it was Swift Two or Swift Three.

Speaker B
So swift, it's annoying. In Swift One string was a collection. In Swift Two, they removed that and then in Swift Three, they decided, no, that was actually good. We're putting it back.

Speaker A
Okay.

Speaker B
And Swift Three was also where it got the ability to correctly count characters.

Speaker A
Got you.

Speaker B
Yeah. It's even made more complicated by this thing that I find, like, not a lot of people talk about, but makes me pretty annoyed, which is that you can compose characters using, like, let's say, the E and the combining acute accent. Right. And Switch treats that as one character. But your font can also compose two characters together with a ligature. So if you have a special font that handles an F and then an I as one character or as one Glyph, swift still thinks that's two characters, because that happens at the font level.

Speaker A
That's, like, solidly a display layer concern, I think.

Speaker B
But couldn't you say the same thing about the emoji?

Speaker A
Yeah, that's kind of a fair point. I think there might be situations where in Swift, some emoji do appear as a few different characters because there are emoji that are composed of different characters.

Speaker B
And a zero with now, families, family things are represented by man emoji, zero with joiner woman emoji, zero with joiner boy emoji, zero with joiner girl emoji. So they're actually seven characters or seven code points.

Speaker A
Correct. It looks like in Swift Four, at least, it considers all of those to be joined together into a single character.

Speaker B
Yes. You know, the other fun thing about ligatures is that there is an Fi and an FL ligature built into Unicode, but they're technically deprecated, and you're not.

Speaker A
Supposed to use them because it's a display level concern.

Speaker B
That's right.

Speaker A
That's interesting.

Speaker B
Okay, so let's take another tack at this. In JavaScript, what you can do is if you have, let's say, a family, you can replace all of the girl emojis. Like, you can do a find and replace a language. Might give you a function to find all the instances of this substring and replace them with this new substring. So you can replace all the girl emojis with boy emojis in that string, and it will actually render out a new family for you because it's seven different characters instead of one character. That's represented by seven code points, the way the Swift models it. So you could do goofy, weird stuff like that in JavaScript.

Speaker A
And you see this especially with JavaScript, if you go to, like, Google Docs and put in a family emoji or put in a thumbs up emoji and then put your character to the right of that emoji and hit backspace. So I'm doing this right now on my computer. I have a family with four people in it, and if I go to the right of it and hit backspace, then it deletes one of the people in the picture. Now I have an emoji with three people. It does. And if I hit backspace twice more, getting rid of a person, and I guess a zero width joiner. I have just two people left.

Speaker B
Wow. I did not know the Google Docs does that. That's very funny.

Speaker A
Yeah. I'll get a GIF and we'll put it into the show notes.

Speaker B
That's really cool.

Speaker A
You should do that, for sure, because it's kind of fun and interesting to see these abstractions kind of leak through.

Speaker B
Yeah. So let's get back to this kind of original question of all right, you.

Speaker A
Were going somewhere with this.

Speaker B
Yeah, I've got a broad arc in my head. I'm happy to take tangents, though. So the original question that we had is, how do we replace the third character with, let's say, a hyphen? And of course, you're correct in asking, what do you mean third? What do you mean character?

Speaker A
Right.

Speaker B
And so now that we know all this stuff about strings, we can kind of begin to answer it. And the answer is we can't go to the third character because we don't know where the third character starts without looking at the first and the second character.

Speaker A
Yeah.

Speaker B
Right. So in Swift, there's no way to write the code that will jump to that third spot and jump to that third spot and perform some operation.

Speaker A
Right.

Speaker B
Yeah. So that means that that will always be an o of one operation. But what Swift does give you is it does give you access to its indices. And an index for a collection is something that you can give back to the collection and get back the value at that index. And that has to happen in o of one time.

Speaker A
Right.

Speaker B
Crucially said that kind of poorly, but I think it makes sense.

Speaker A
So maybe a different way to phrase it or think about it is an index is something that a collection can give you. You can get an index from a collection, and it's an opaque type. It's not necessarily an integer like you would expect for an index into an array. And so for something like a string, you can get an index into the string, which is an opaque type, which you need to use special methods to operate on. But you can hand it back to that string and get a character out in constant time, over in time.

Speaker B
If you have that index, then, then you can replace the third character once.

Speaker A
You have that index, but you can't get that index in constant time.

Speaker B
That's right. Now, I actually kind of like that, because what it means is what you can do is Swift has methods for, like, given an index, let's say the start index, advance me by three, or something like advance the index by three. And because that's kind of hard to work with, it suggests to you that, hey, something weird is going on here. I'm maybe not supposed to be doing this. And that kind of starts to hint at my broader point here, which is that if you're doing something with Swift strings, and if it is proving to be painful, then you are in the territory where you might accidentally be taking too much time to do something that should be simpler.

Speaker A
Yeah.

Speaker B
So a nice way to illustrate this is an example in Swift, it ends up being accidentally quadratic unless you do it right. So let's say you wanted every substring of a bigger string. You want the first character and then you want the first and second, and then you want the first, 2nd, third and then all the way until you have the full string, right? You want like this continually growing string that starts from the beginning and ends at all these various points. This is useful in various situations, some of which are interview questions, but some of which are actually useful in day to day app writing. If you try to do that by going from if you try to loop over the numbers one to string count, you're going to have a bad time because you're going to end up using that start index every time, advancing the characters every time and it's really just painful and doesn't feel right to do. And that's like if you try to iterate over the integers. But if you just do like for index in string indices, you will get the index each time. And when you use that to slice up your string into your substrings, then that will happen in o of one time. And this code that was accidentally quadratic before because every time it was stepping through all the indexes to find the right one that you want, like the fifth one, the 6th one, the 7th one, and so on, that's an oven loop. And then your whole bigger loop is an oven loop, so your whole thing ends up being oven squared. Whereas if you use the indices, it knows where each index is and gives them to you once and you can instantly slice at that point and end up with the string that end up with these slices in o of N time, which is what you would expect. That makes sense.

Speaker A
Yeah, I think so. Yeah.

Speaker B
So what this person was doing in trying to solve this problem was really difficult to do with the ergonomics of the way that string is set up. But maybe that's actually good. Maybe the reason that that happens is because he's doing something that he's, quote unquote, not supposed to and the system of functions and types and stuff is getting in his way and preventing him.

Speaker A
From doing it or making it harder to do it because he's trying to do something that can't be done efficiently and correctly.

Speaker B
Right? Yeah. And so I think at that point it becomes kind of more of a messaging question of how do you produce this negative information in everybody's brain that says, hey, if swift strings are proving difficult to use, that means you might be using them wrong, and you might be hitting, let's say, accidentally quadratic problems, which I noticed you put the accidentally quadratic blog in the show notes. That is a great blog. It's a great blog and everybody should read it.

Speaker A
Yeah, that's true. I hadn't really thought of it as a messaging problem. After you put this resistance in someone's way, what do you do then? That's an interesting thing to think about. Is this something that you've thought about how this messaging can be accomplished more than just someone noticing that this is painful to do?

Speaker B
Yeah, I think that one of the problems with Swift is that a lot of what's going on with the language, once you've spent time with it, you understand why it's that way. And it's a pretty good decision ultimately, or the decisions that they've made are good ultimately, but they're not really effectively messaged. So, for example, I wrote that blog post about safety in Swift where you think that safety doesn't mean it means that it doesn't crash. But what they mean by safety is it never returns garbage memory to you.

Speaker A
Right.

Speaker B
And that distinction is pretty different and causes people to see crashes and say, hey, I thought Swift was a safe language. And then of course they go and they ask somebody and say, well, when they say safety, they don't really mean that kind of safety, they mean this other kind of safety, which is also useful, but maybe less useful than you originally expecting. And then there's other stuff there's like, let's say single versus multi pass sequences, which has been a particularly big bugbear of mine, and other stuff like that, where it's like they need a way to effectively express these little thought memes to people better, I think. And this podcast is one of those ways to express the thought meme.

Speaker A
That's true. This podcast, Swift unwrapped other great podcasts about Swift.

Speaker B
Yeah, and there's two other things I could talk about. I don't know if this is interesting, Chris, but we could talk a little bit about why string doesn't conform to Mutable Collection. Is that something you'd be interested in?

Speaker A
Cool. Yeah, that sounds like good discussion.

Speaker B
Yeah. So if you've seen, let's say, the talk I gave on all the protocols of sequencing collection. Mutable Collection is the one that gives you the ability to set values via the subscript operator and it also gives you the ability to do a couple of other operations like sorting. It gives you the ability to sort, to partition anything that requires to swap values at certain indices. You'd use the Mutable Collection protocol and so you'd think, well, strings are mutable in a sense. Like I should be able to replace a character if I have its index. Right. That is kind of this original question that we were talking about, but because as you mentioned earlier, there's things like composable sequence, composable characters like an E and an acute, which are two separate code points that compose. To one character. You could replace a character at an index and actually end up changing things in the Mutable collection, in this case, the string that don't have to do with that index. Yeah, if you had like an F and then like a combining acute mark, normally that would render as two separate characters because the F can't combine with the acute. But then if you replace the F with an E, then all of a sudden that can combine. And so replacing a value in your string actually ends up changing the length of your string.

Speaker A
It can change the number of characters or the number of in swift, you'd call them like graphene clusters in your string.

Speaker B
Yeah, exactly. And according to the sort of the documentation and the requirements that Mutable Collection has on its conformers, that is not allowed reasonable overall. Yeah, and I think there are certain operations on Mutable Collection that require that behavior to be the case. Because you can imagine if you're iterating through one by one and then let's say you replace that F with an E and then everything shifts over one character and then you advance your index. Now, you may be pointing at garbage like you could be looking yeah, it could be crazy.

Speaker A
Well, you can't iterate over something while you mutate it anyway. But I take your point.

Speaker B
Yeah, well, you could do that with an array. I don't know, you couldn't in objective C, but I think you can you.

Speaker A
Could do that with an array, I guess, because you would probably copy on write, right?

Speaker B
Yeah, I think you make a copy when you start the sequence.

Speaker A
Yeah, I'm not sure anyway, don't iterate things that you're mutating don't mutate things.

Speaker B
That you're iterating reverse first and do it from the back. Yeah, that helps sometimes. Yeah. So that's the one thing about Mutable Collection and that's why you don't get some of the things that you would normally expect. Another great example is like Mutable Collection allows you to reverse the elements of the Mutable Collection in place. What would that do for strings? Let's say you had like the same example, let's say you had an acute combining mark and then an E. Normally that wouldn't combine because the diacritic has to follow the character. But if you reverse it, then all of a sudden they can combine. And now your reverse thing is one element shorter, one item shorter than your it just would do really weird stuff. Same with sorting swapping, it would just break a bunch of stuff. So that's why mute string doesn't conform to Mutable Collection and that's why you can't use the setting subscript on string.

Speaker A
Do any of the views into string that you can get that like a Utf Eight view into a string or Utf 16 view into a string conform to Mutable Collection. Because I think that you get around some of these problems. Like if you were using a utf 16 view into a string, right?

Speaker B
Yes. You do get around some of the problems that way, but I don't know if that means they conform to a mutable collection.

Speaker A
I feel like views are mostly used for reading. I don't know what the semantics would be for them to be mutable.

Speaker B
Yeah. Would it mutate the underlying string as well? Yeah.

Speaker A
That's really weird.

Speaker B
That's definitely something to do a little research on.

Speaker A
Yeah.

Speaker B
I will say one really nice thing is that the Utf 16 view is guaranteed to behave exactly like an S string.

Speaker A
Is that an intentional design goal or does it just happen to be the case because NS string is Utf 16 under the hood?

Speaker B
No, it's a design goal. It's intentional.

Speaker A
Okay.

Speaker B
Yeah.

Speaker A
That's good to know.

Speaker B
Yeah, definitely. Yeah. It doesn't look like the views are mutable.

Speaker A
Okay, that makes sense.

Speaker B
I guess that's probably for the best.

Speaker A
I think that feels correct to me. Yeah.

Speaker B
So if you're dealing with ranges, for example, and you have an NS range, there's other ways to deal with ranges as well. But Utf 16 view is guaranteed to have the exact same semantics with respect to ranges, with respect to all that stuff as NS string. So if you need to bridge to NS string or you have some data that came from NS string, you can use the Utf 16 view to work with it.

Speaker A
Yeah.

Speaker B
The last interesting thing that I want to throw out as kind of a slightly more practical interview question type thing, but slightly more practical than replacing the characters at a certain index, is this concept of a word ladder. Have you ever heard of a word ladder?

Speaker A
No, I haven't.

Speaker B
Okay, I will lay out the problem and then if Joe can throw in a little spoiler horn so that if people want to go home and try this, they can pause the episode, try it, and then come back and listen to the ad where we talk about the solution. Does that sound good?

Speaker A
Yeah.

Speaker B
Cool. Okay, so the way the word ladder works is you are given two words. Let's take four letter words to keep things simple, and in this case, let's try like tune and plea. P-L-E-A. This is just an example I found on the Internet. The idea is by changing one letter at a time, can you get from the first word to the second word. Okay. That's the problem.

Speaker A
Okay. Yeah, I see.

Speaker B
Now, Joe, if you could fire off that spoiler horn and now we can talk about sort of the solution to the problem. So if you think about it, this is essentially a graph that you want to traverse. Each word is a node. And then when you bridge to another word, that means that it's like a one character transformation that bridges you to another valid word based on some lexicon, which is a fancy word for dictionary that we don't use in programming because dictionary already means something. So it's basically a graph traversal problem. And you need to step through this graph and try to find a path between the node tune and the node plea. Does that make sense?

Speaker A
Yeah.

Speaker B
So the way that I did this is I basically wanted to change each letter in my source word, like the letters T-O-O and N, change them one by one to all the letters ABCD through Z, and then change them, check if that's a real word. And then if it's a real word, then that's like another node that I need to explore. But you can imagine this is the exact same problem that we would have earlier, is I can't just change the fourth character.

Speaker A
Yeah.

Speaker B
Even though I know that these are only going to be the letters A through Z, they can be represented by eight bits. I know they will always be represented by eight bits. And theoretically, if I did know the offset or the way these bits are packed together, that I could just jump to the 24th bit for the third letter. Swift doesn't let you do that. So what I ended up doing is I ended up converting the string to an array. So because string is a collection, you can just pass it to an array and it will make an array of all the elements of the string. In this case, the elements of the string are these characters, these graphing clusters that we're talking about. And so then I ended up with a four element array. And with an array, it's very easy to replace one item with another item.

Speaker A
It's something you can do trivially easily. And constant time.

Speaker B
Exactly. So what I basically do well, it's not really constant time because you have to convert to an array to begin with. But once you have the array, then it is constant.

Speaker A
Yeah, right. I just mean replacing an element in an array, constant time.

Speaker B
Right. And then what I do once I have that array of characters is I actually do convert that back to a string, which I think is also O of N again, but that's fine. Check the lexicon to see if that word exists and then check to see if I've already looked at that word and do all the other logic that I need to do. So that's like one example of where you do need to kind of mutate this character wise, but the string API doesn't really give you a way to do that. But I think the key there is to realize you're not actually thinking about this in terms of a string of letters, you're thinking about this as an array of characters.

Speaker A
Absolutely.

Speaker B
And then if you convert into that new domain, then the operation that you're trying to do is actually trivial.

Speaker A
So I'm looking at your implementation here. You use all the sort of building blocks you would expect you've strings. You've arrays, as you mentioned, you use a set to check, I guess that's a set of all the possible four letter words.

Speaker B
That's a set of the words that I've looked at already and I don't want to look at again. Because you're going through a graph, you have to remember what you've looked at already so you don't end up in infinite loops.

Speaker A
Well, you also have a set of your four letter strings.

Speaker B
Oh, yeah, that's the lexicon of all the valid four letter words in English, based on the dictionary that I happen to be using.

Speaker A
So what if you now that we have conditional conformance, what if you made arrays of characters conform to equatable and hashable and just put those arrays in your sets directly? I bet you could write this entire thing without actually using the string API, without actually using the string type at all.

Speaker B
Yes, you absolutely could do that. The only reason that I didn't is because I wrote this in Swift 4.0. And you don't have hash ability. Well, yeah, you don't have hash ability and equatability by default, but with 4.1.

Speaker A
You could and it would make a lot of repeated back and forth between strings and arrays. It would be a whole lot more efficient.

Speaker B
Yeah, I better be way faster, now that I think about it.

Speaker A
Yeah, that may be a fun exercise for you to do. I don't know if you want to share the were you planning to share this gist?

Speaker B
What do you think I should do? Should I share it or should I let the listeners suffer through the nerd snipe and then give it to them later?

Speaker A
I mean, we just discussed the code that may be useful for people to be able to look at it.

Speaker B
Yeah, that's fair.

Speaker A
Although you should fix your quotes.

Speaker B
I did fix the quotes. Slack made them smart quotes instead of straight quotes. I fixed them, I think, everywhere.

Speaker A
I just had to refresh the page.

Speaker B
Well, there's actually two more at the bottom that I didn't catch.

Speaker A
Boo. Yeah, there are boo to Slack. Okay, that may be a fun exercise. So the takeaway here is if you're thinking about a string as a collection of characters that you need to mutate and do things with, maybe model it as a collection of characters.

Speaker B
That's right. And that way they aren't variable width, they're fixed with. You can jump to anyone instantly using integers. You can do whatever you want to it, but it's not a string anymore. It's an array of characters.

Speaker A
Yeah, strings are hard, man.

Speaker B
Strings are really hard. My last note is also Swift Three made a big mistake when it brought everything over from collection. Now you write string count to get the length, which makes no sense. I don't want the count of a string, I want the length of a string. And they should just alias length to count and ease my mind. That's my only other thought.

Speaker A
Yeah, I could definitely see that being a complaint. You can always add an extension that is called length, and that just calls count.

Speaker B
Yeah. And you know that.

Speaker A
I do, yeah. I believe it. Cool.

Speaker B
Cool. Yeah. So that's some thoughts on Swiss strings.

Speaker A
Yeah. So the takeaways here are from this episode. I think that strings are more complicated than you think. Unicode is horrendously complex, and if you're trying to do something with a string in swift that seems unnecessarily painful, that seems inefficient, it probably well, probably is inefficient, and it probably is designed to be painful to do that because it's inefficient. And you may be able to find a different way to approach your problem. Maybe something that uses a raise, like you did in this example, sirous, that lets you do whatever you're trying to do in a much less painful way with the semantics that make sense for the problem.

Speaker B
Yeah. I think that's a very perfect way of wrapping up what we've been talking about.

Speaker A
Great.

Speaker B
Yeah. So be careful with your strings people. They're comp. They're complicated. For good reason, but they are complicated.

Speaker A
Yeah. Cool.

Speaker B
All right, well, as always, Chris, it was wonderful. I will talk to you next week.

Speaker A
Yeah, it's good to talk to you. Have a good have a good weekend. Bye.


Speaker A
So we're gonna do a special episode this week. I'm Sirous. I'm Chris. I'm Caleb. And I'm Sam. So, yeah, we we kind of have two guests, and they have two guests, so Caleb and Sam host a show called Runtime FM, and Chris and I host a show called Fatal Error. And so if you're a listener of either of those shows, you're also getting kind of a bonus episode episode of the other show. And we thought we'd just all get together and do a little joint episode and see where things see where things go. Yeah. So for today's episode, we thought that we might discuss the phrase not invented here that you might see abbreviated elsewhere as NIH and I don't know, does someone else want to take a stab at what that means, or should I go for it? Let's do it. Let's just dive right in. All right, so not invented here. You can kind of tell from the phrase what the gist of it, what sort of the gist of it is. It's a tendency that an organization or a team might have to sort of just pass categorically on external external maybe tools external dependencies in favor of reinventing that particular wheel internally. And there are plenty of valid reasons to do that. Right. There are concerns about taking on external dependencies that I'm sure we'll get into, but a lot of problems have already been solved really well by other people, and so it can also be a harmful tendency. Yeah. So the term is usually it's said as like, as the Wikipedia article says, the term is normally used in a pejorative sense. Like, if you are too good to use the dependencies that everybody else uses, then you're just wasting your time. But sometimes, I think also, especially with experience, you find that sometimes the opposite is true. And I was thinking maybe we could talk about our experiences with when it's good to do when it's good to rewrite it yourself, when it's good to use the dependency from someone else, when you don't have a choice in one way or another. So maybe talk about a little bit about our experiences with that kind of thing. Yeah, I think Sam and I have talked about this maybe a couple of times along the way. I'm sure that all of us have strong opinions about this, but personally, I definitely don't see this as a bad thing. I myself, and I wish others would be more diligent about due diligence when looking at dependencies they're bringing to their software. And I think that culturally, iOS people have kind of gone down the rabbit hole of, like, if I want to solve a problem, the first place I look is cocoa pods. And that's never my approach. And so I think there's a lot of cultural things there's, like tooling things that make this thing kind of easy, where I don't ever want to write something myself. I always want to use something else's tools. And there's so many problems with that. And I think there's a lot we can talk about. I've worked on a couple very large apps that come in later and like, okay, now there's all this legacy code. Let's figure out how to work on this. And a very common thing is to have multiple networking libraries or multiple animation libraries or whatever else. And it's not like, it's like, hey, we should remove all these. And I'm not proposing we make our own yet another networking library. It's like, we just use the Apple stuff and we don't need all these other dependencies. I think usually when I'm in the approach of let's remove some stuff, it's like, let's just use the Apple stuff, not all these dependencies. Right. Honestly, working on a project that has multiple networking libraries sounds, like, really horrible. Yes. On the last project that I started from scratch, the first dependency that I pulled in and the first time that I needed to use Cocoa Pods was for Mixpanel, which is like, are you really going to write all the API endpoints yourself? Probably not. I have a mixpanel library. Sam has done that. Where can I find it? Because I feel like I might want to use it. Mixpanel. There you go. Boom. Put that in the show notes. That may be one reason that you take on an external dependency. Is it's for a service that maybe you don't want to write against their API and replace their SDK? Or in a lot of cases where an SDK is the only way to use some external service, but there are other cases where that's really not the case. Like something with networking library. Caleb, you mentioned due diligence when considering whether to take on an external dependency. What are some of the things that you or that any of us look for when we're trying to do that? Due diligence? What does that mean to you? For me, I think a lot of the languages there was like the JavaScript thing a long time ago with the left pad or whatever, where if a library does one really tiny thing, I'm okay taking that on myself. And if there's bugs in that, I'll find them, I'll fix them, I'll write tests, I'll deal with it. And for things like that that are so tiny, I've seen people there are whole Cocoa Pods for managing the network spinner in the status bar on iOS, and that's a very tiny thing. And in our shared framework at work, I have a class that is responsible for that and all of our apps and frameworks can consume that and it works just great. And now I don't have to have someone else's code to manage that. I don't have to have another library, another framework, another thing that gets loaded at runtime. And so I think how big is it? Is one aspect of it. If it's like a very it's got a big library, active community, a lot of traffic on GitHub. I'm more open to it, and I also think I measure like general code quality. I know everyone has different measuring stick for that, but personally, I'll at least glance at the code. And if I see a lot of in Swift, especially if I see a lot of force unwrapping and things that are optional everywhere, that don't need to be, and it clearly wasn't very well thought out or everything is open. And it's like I want people to think about their code running as a library in someone else's app and try to be a good citizen of that. And not everyone does. And so I think it's like there's a number of factors, but I'll check all of those before I add a dependency. I would throw in test coverage as well, right up there with code quality. Is there a way that you check the test coverage or do you download it, run the tests, and then look in Xcode to see how much of the app has or how much of the code base has test coverage? I mean, often just looking at the test in the GitHub repository can give you a pretty good idea of whether this library of whether someone thought about adding test coverage for the things that are important in this library that's more often than not enough to give you, I think, a pretty solid idea of where the library is. I feel like the first question is just is there even a single test? I'm guilty of that, having some with that. I think Coco Pods has done a decent job with this though, is they have like, Pod they call it Health or Pod score or something where it'll show you test coverage, README coverage, commenting or documentation, that kind of thing, as a general sense of the quality of the library. And obviously that's not perfect and you should still do your own research, but at a glance, it's really easy to tell, like, this thing has zero test targets and like, okay, we should think about that, right? We call it the Cocoa Pods. Quality index. Yeah. So, okay, we're looking for really well thought through code that solves a nontrivial problem, good test coverage, and an active community behind a dependency. So what are some things that we look for? If you're looking at a GitHub project, how do you tell if there's a healthy community behind this project and whether it's a well maintained project? Generally just look for good documentation in the README, or if they have a link to generate documentation somewhere and look at issues. And if there's a bunch of issues that are like years old, like in most of my repos, then cool, don't use it. But if there's a bunch of stars and tons of closed issues and the open issues aren't super old, then I think that's a pretty good way to judge quickly. Are the maintainers involved with this library or is this basically abandoned? Yeah, there's also like a kind of a weird counter thing of sometimes libraries are just done, there's just nothing else that the author wants to add to it. And so it may not have a commit in the last two years, but it may be like a pretty good small thing. Maybe it doesn't apply for our industry because Swift changes every year and there's breaking changes all the time. So maybe it's just not as good of a metric as it could be for our industry. I know my Q chain wrapper I haven't worked on in a super long time. There may be some commits, but it's like someone found a typo somewhere. I had to convert your MD Five thing to Swift Three and it took me like 6 hours. It took me like the better part of a day. It was horrible. It's definitely already swift three. Oh, I think it may have been before it was Swift Three or something. There was some kind of situation. I don't know. I remember that being painful when I did it. Yeah. With unsafe bytes thing is just brutal. Yeah. I wrote mine in C to avoid all of that. Yeah, there's like a whole separate target just for the stupid module map thing. It's the worst. I wrote all of that so I could use it in mix panel to MD Five, the stuff. That's why I made a subdependency right there. Writing that in C, of course, doesn't avoid the unsafe code. It just avoids the unsafe wrapper. Yeah. I just don't have to think about it, that's all. Yeah, everything in C. I think you could just assume Swift would call unsafe. I know. For most of my projects, I rarely use anything that I didn't write unless it's like something I have to use. A current client uses Instabug, so I have to use their thing. Right. So is that like a closed source SDK? Yeah, it's like a binary. Yeah. So, friends of both of our shows, I think Matt Bischoff and Brian Capps, when they worked at the Times, would often do reviews of SDKs. And if product wanted some SDK for whatever to be in the app, they would go to the company that provides the SDK and say, hey, we need to look at the source code if we're going to put this in our project. And so that they would do a code audit and maybe even open a couple of pull requests on that thing to say, is this actually good quality? Is this going to swizzle UI application send event and we're just going to have to live with that for the rest of our lives or can we make it better? Yeah, I mean, I think if you're the Times, you can do that, but in my situation, I show up as a contractor and they already made the decision they love instabug. So you just have no choices. Yeah. Yeah. But ideally I think that's a great path if it's something that your company has the weight to pull off. I mean, you will find some pretty terrifying things in some of the closed source SDKs that people want you to add to your apps. Yeah, this definitely happened when I was at Rap Genius. There was an SDK that had a bug in it or it had too much logging and they didn't want to work on it because they had had one person who was like a Java engineer write it three years ago and we had to use it. And so I ended up giving getting them to give me access to the source code and I just saw the most horrible and horrific shit was just really bad. Sorry for cursing. That reminds me of or that gives me another idea though, is when you bring in a dependency that has the dependencies, you're now responsible for multiple levels of these things. And you mentioned logging. That's what made me think of this, is I used to use and still kind of do use Yap database, which is a cool little key value store in iOS. And it relies on cocoa lumberjack for no reason only, so it can have nice logging functions. And I get that maybe you want that when you're working on the framework, but you do not have the right to tell me that I have to have Google lumberjack for your framework to work. And a little while after I complained about it, they added like a flag that you can turn off. And when you compile the code, you have to if def this thing and it will change the so it doesn't require coco lumberjack, but things like that. Whenever I see a big library that depends on it's, like an analytics thing that requires AF networking, it's like, well, what if I don't want AF networking? Right. Or what if I rely on a different version of AF networking? Exactly. Yeah. So that's something that in theory, being able to ship totally dynamic frameworks that can hide their internal dependencies should fix that. Right. So this is iOS programming where we're not allowed to have nice tools. So it's pretty much out the window. Well, it's funny, I tweeted a while back because I had to use as a Parse SDK for something and there was like all these dependencies and I was like, this is ridiculous. I feel like something as prominent as Parse, I mean, back when that was, a thing shouldn't have dependencies, you should install their thing and that's it. If the mixed panel SDK depended on a networking library, that would be not ideal. And then a bunch of JavaScript people are like, well why they shouldn't need to make all those things or vendor all this stuff because now they won't get updates or whatever. They're very anti what we would prefer is just like everything has no dependencies that you would pull in for most things because they have a good package manager, at least in their mind. I'm not qualified to comment on that. I was debating with them like left pad and all that and they're like, well, why would I write this code? Like, this is tested and I didn't make it, I'm just going to use that. The complete opposite of our view. And I didn't have any good reason. We debated it for a good ten minutes while I waited for their hipster coffee dim and I didn't have a good reason. Neither of us had a reason to convince each other of the other point. It was just like their preference and our preference is kind of what we landed on. I think there's something we said like, Caleb and I have written stupid content mode math way too many times for Aspect Fit and all that junk and I would love to never write that again, but I don't know of any libraries that are small that do that. So I'll probably do it again, which is dumb. But on the other hand, I don't want a dependency that I don't trust to do that. I don't know, I'm like super torn with this whole worldview. As much as I prefer to just keep everything small, I'm not convinced that's like the best solution. Well, that sounds like there's an opportunity for you to write a small library that does that and a small dependency manager that's designed for small libraries. No, I'm kind of kidding, but I'm also kind of serious. Recently I've been using a bunch of small things that I've written for Swift projects over and over again. So there's like an object storage thing. It's like 100 or 200 lines of code, but it works. It works with all the things it needs to do. It's generic. There's the little promise thing that I wrote. Sam, I know you have like a JSON parsing thing. I have one of those too. And I feel like if there were a world where there was a dependency manager that suggested that you should use really small dependencies and like a build system that enabled you to use more than ten dependencies without crashing your app on launch, that we could have a somewhat nicer thing. Because there has to be a balance between I have written JavaScript and the dependency tree that you get is completely crazy. It's just like, thing depends on thing, depends on thing, five or six layers deep and it works and it does have its benefits, but at the same time, I guess we've all been burned in the different ways that it can go wrong as well. And so maybe the balance is like lots and lots of little tiny libraries. I don't know. I'm going to beat my SPM drum again. Yeah, I hope that SPM is the answer to this, but I don't know where it is or when it's coming. So I feel like Swift itself and SPM are both answers to these problems. Right? Because one of the biggest issues that I have with bringing in a lot of objective C dependencies is like, okay, am I going to name collide with something? Is there going to be some static function that names collide with static function in a different library? Or are these things going to swizzle each other in incompatible ways or whatever? And like, Swift removes the need or even ability in some cases for any of those things to be an issue. And then SPM, if you have the ability to build static libraries now, you suddenly have the ability to make very small, very safe libraries that are linked into your app once and then done. And if you need a feature, it's going to be code size in your app somewhere. Whether or not that's in the section of the binary that is static library code, or if that's in section of binary that's your code, it doesn't really matter. But you're not like incurring a dynamic load time. And so I think that takes away so many things. For me. There's whole classes of bugs that you can't even write in Swift without doing the wrong thing. And so I feel less compelled to look over that code. For example. So when are we going to be able to use SPM on iOS projects? I do not know. As far as I know, nothing has been said about iOS. Yeah, I'm really disappointed about that same, like, result. For example, I've written result in every project I've worked on in Swift, just like a little enum and their result is much more full featured. Like whatever result everyone uses anti. Typical rob Rick. Yeah, but I don't want to pull in a dependency and yet another dynamic library to load when the app loads. It's just not worth it. So I'd rather write 20 lines of Swift than pull this in. But I think ideally I'd rather just use this because it's tested and smarter people than me have thought about how to do this. I don't know. I think we're all skewed towards as little dependencies as possible because our ecosystem sucks. So I'll come out and say, I don't know if I'm quite as skewed toward as few dependencies as possible as the rest. You are. Especially at work. I'm certainly careful about taking on dependencies, but there are a lot of things that just have been solved that I don't feel interested in reinventing and it's not really worth my team's time to reinvent. Another of the things that we look at before we take on a dependency and it's something that I don't think we mentioned before is whether it's something that the team would be comfortable taking on and maintaining if we had to. Right? Like if we had to take ownership of this code, is it a manageable code base. And some of the questions like, is it a quality code base? Are there tests also play into this? Right. I feel like ultimately you're assuming that responsibility for that code base as soon as you type like pod install. And that's the implicit thing that most people aren't ready to do. Right, but I think it's I mean, as long as you really do consider that, like, this is something that we may have to maintain for at least long enough to move our code off of it to something else. Maybe something that we wrote or maybe something some other third party library. As long as you take that into account, as well as everything else that we've talked about. I don't know. I'm not convinced that taking on dependencies is always such a bad thing. Right. So let me ask you this. When you start a new project, what dependencies are like you can install first? Man well, I haven't started a totally new project in a little while at this point, so I don't know if I what do you feel like you can't live without? What do you feel like is going to be useful in maybe every project that you work on or something? Here's another way to put it. Give us some examples of you all started kind of a new app at the Times. This is true. What are some examples of the dependencies that you've pulled in for that already? So some dependencies that we pulled in for this? We pulled in Swifty Beaver fairly early on the project, thinking that it might be useful to have this something that supports remote logging. Here we're actually kind of TBD on whether we're actually going to set up remote logging, but we wanted to have that capability so that we're not polluting our entire code base with Swifty Beaver specific API. We have wrapped that in our own logging API, so we can swap that out under the hood. That's probably another good thing to do. As long as you're taking on dependencies, try to isolate them if you can so that you can swap them out under the hood. We are using Async display kit, which did bring us a pretty nice performance improvement. Sort of a big part of our app is a big collection view. Right. And Async display kit is making that a very nice scrolling experience. Let's see, what are some other things that we're using? We're using Yap database, which again is something that I don't necessarily want us to write a persistence layer from scratch, but I also feel like at least some of us on the team would feel totally comfortable taking on that responsibility, at least for several months if we had to, if the project were to be totally abandoned. Right, yeah. Yap doesn't seem like something that's impossible to maintain. No. And I mean, we looked at that when we were deciding whether to take that on. Right, but it seems reasonable to maintain hypothetically. Let me ask this. Would any of you bring in a like, we talk more about infrastructural stuff like network clients and persistence layers. What about like a UI library? I remember a little while ago, like a form that when you tapped on the label would like slide over here and it would do like a fancy animation. Would you bring in a UI library? I generally don't. In my current project I have two. I did make my own Float label thing with the fancy placeholder that moves up. Right? Float Label, that's what it's called because mine's like insanely small and simple and the main implementation links from the Dribble shot is pretty complicated. Last I looked at it, I could be totally wrong, but they're already using Country Picker. I'll put a link, I don't remember who it's by, but it's like a nice picker view that has flags next to each country name that would have taken forever to compile. And then there's some fancy spinner thing they are already using but looks like totally fine. But I'm with Caleb, I generally try to avoid UI things because, I don't know, I guess in seven I haven't really used any because they were all like old looking and then I never picked new ones since then. Yeah, I think for me, a lot of the times popular UI things will tend to have I don't know what you would call this, but everything is just overly customizable and I never need that. I want a 20 line view that is a little like Modal progress HUD and I made one and it's in our shared code framework at work. And I could have pulled an SP, Progress HUD or any of the others, but they all have customizations for everything and some of them have, like, iOS six branches where it looks different in that. And we don't need that code anymore. And so it's like I'm running. For me, all of that code ships in my app to the App Store and if something goes wrong with it, for some reason, now I'm on the hook for it and I'm not a fan of that. So if it's like something that's small enough that I can build myself, I will build it. So the one sort of big Uipod that's in our app that we're rewriting is a pod that does the sliding side menu for an iPad user interface. And that's something that we totally could build ourselves internally. We want to get something up and running here. The code looks pretty sane and we're again comfortable with in the future potentially forking it and sort of adopting it and making it our own or just completely adopting the project or moving away to some other library that does this. And in my mind that's really kind of the key point here. Is this something that you, first of all are comfortable with? The code that's there you're right, Caleb. That if it's overly customizable, right. That's not necessarily something that you are interested in taking on. But if you're comfortable with the code that's there and feel like at some point you can fork this and make it your own with some level of confidence, then I personally still feel okay with that. I think that's a really good example of a UI library that's like a good one to pull in because there's so much stuff with those sliding panel things, like all the gestures and animations. I've started building one of those while back because I was like, I don't want a UI library. I was like, this is going to take a super long time. I'm just going to pull in this thing. And then I was very happy with it. I don't remember which one it was, but yeah, I think that's a great example you mentioned, though, with the beaver thing. You encapsulated it. Do you do that with all of your dependencies? If possible. And what about UI ones? How do you handle that? If possible, we do prefer to do that, or I do prefer to do that. The UI ones, it's often harder, right? Just because well, why is that? It seems like it's often harder with UI ones, but with something like a logging framework, that's obviously pretty trivial to wrap something like hockey is really you have pretty limited exposure to the hockey API in your anyway, but you can wrap that behind its own little wrapper if you want. I think it's kind of a function of the surface area that the library exposes. Like, if it's just a couple of functions that you need to expose, not so bad. Like, if it's networking, you kind of just need one function to shuttle everything through. But once you have a UI library, there's like all kinds of weird customizations and you have to be working with that class through the whole thing and pass that through your system and it becomes a little bit harder to kind of wrap and try to hide those details away. I think one of my favorite things I'll look for in a library is how much of it is a singleton. Yeah, that's another really scary part of some of these libraries, is, like, you want the API of your library to be really nice and really easy to use, and so you end up having to do these really weird singleton hacks and global stuff. And just to make sure SV progress is a good example. I've definitely used that one. In the past, I ran into a particular problem with it, where or not with it, but with the concept of just a global loader where one screen is loading and then maybe you tap to the next screen and then tap back. You want the loader to kind of go away and then come back when, and only when, that screen is visible. And it kind. Of lets you do that, but not really. Or another thing would be like a counter for like and they did add functionality for this for saying, like, I have three network requests in flight and I only want one loader and I only want it to be dismissed when all three are done. The weird global stuff they do to make their APIs look really nice is sometimes scary as well. And that's something that you definitely want to check for in your sort of is this solid code? Let me rephrase that, right? Like, does this meet the and that's something you definitely want to check for in your sort of initial evaluation about whether this is solid code that you actually want to ship in your application, right? Yeah, exactly. So it sounds like we're all kind of on the same page about at least taking a gander at what's going on inside a library before we add it in, thinking about the implications of maintaining it, what if it goes away, how am I going to replace it? That kind of thing. So I think my last question for everyone would be I see people all the time will ask a question about how do I do this thing? And instead of asking it like that, they'll be like, which pod should I use for this thing? And I wish there was a nice way or like an easy way for me to work with people to that's not the right approach. Think about what is the problem you're trying to solve? Go find the API for it. How hard is the API to work with? Work through the problem yourself instead of immediately going tocopods and trying to find someone else's code that does this thing for you and subcopods in for Carthage or whatever else. In this example, it's always the same. The manager itself doesn't matter. But how do we work as a community to get people to try and solve these problems and increase the quality of libraries and apps across the board? That's a really good question. I think depending on the team you're working on, right? If you're working on a team with a number of other people who aren't used to thinking like that, then leading by example is a really good approach. That's a really good approach for a lot of things. I just had a really good conversation last week with one of my team members discussing the pros and cons of a specific library that he wanted to pull in to achieve. I forget what we were even talking about, but it was a small library that he was wondering if we could pull in to solve some small problem. And we sort of talked through the pros and cons and determined that, no, actually, this is something that we want to write a little bit of code to do ourself and own internally, but with a lot of things. I think just like conversation and leading by example is maybe you make a small impact that way but it is a really effective way to work through things like this. There's a tweet that really sums up my thoughts on how to approach that, which is a really comical, I think, thing to say. But we'll put in the show notes, but it says, all programming methodologies implicitly devalue thought. And that stuff is super worrying to me and I don't know, to me it's like, I think your question is a really important one, Caleb, and it's just like, how do we say, hey, your job as a programmer is to solve this problem and to kind of just jump to the first available quickest. Thing is, I don't know. I hate this line of thinking, I got nothing. I'm sorry. I think it's like someone new searching for a solution for something. I don't know, I've never done this before. And you come across a library that does exactly what you're trying to do. You're like, oh great, that seems cool, versus I feel like there's a lot less information, like blog posts or whatever else to explain. Maybe you don't need all this stuff, you just need to understand how it works and you can do it. Say, for example, you're trying to do like a custom camera or something. Like AV Foundation is really hard to get started with. And you like, I'll just pick up this library because I don't even know what I need to learn to make my own as someone. Starting out, I feel like that's a much easier solution or like copy and pasting some code from Cycle Overflow than it is to have someone explain it to you. If you're just looking for information, you have to be really resourceful and there's just not a lot of stuff as the alternative to just like, pulling this library. Right. I definitely went through the phase where I pulled in a pod for every behavior that I wanted for my thing and I kind of was burned by that by enough times that it kind of informed how I think about that stuff now. And I wouldn't be surprised if we kind of all went through stuff like that. Yeah, I think I did pretty early on. I remember having like 20 or 30 cocoa pods and those each probably had their own cocoa pods. You can go pretty deep with that, I do say. I think it's been kind of fun starting out. iOS open source wasn't really a thing in our community at all. And so a lot of my early code was looking at early cocoa pods and like, hey, I need to solve this problem. How does this person do it and can I own that? And looking at that and trying to understand the code they wrote and then trying to see, oh, maybe I take it and do this one thing, I can make it better for my use case. And then that was the start of me like, okay, I'm going to write this thing myself. Because I looked at it, I understood it, and now I've learned something about the API, and now I'm more equipped to build that thing in the future if I needed to. I think it's a really good point. I've interviewed a couple of people this week or last week for my client that have never written objective C, which is pretty crazy. They started with Swift and that's all they've done. No way. They have three years experience because Swift has been out for a while now. It's pretty crazy. They're good. They're solid engineers. So when we started, this wasn't a thing like you're saying, so we just did it all ourselves and then starting to pull in tons of pods, and that came out like, oh, look how easy this is. Then it's like, well, maybe never mind, let's go back to what we were doing. But I guess this next batch of developers never had that first experience, so they're just reaching for what they've known, which is grab a bunch of dependencies because it's easy. And I don't necessarily think that's bad. I think the bigger problems are like dynamic load time and all that stuff, and not necessarily just tons of dependencies. I mean, there's clearly issues with that as well, but I think I'm more unfairly skewed to less dependencies just because that was my first experience. I think we all agree, though, that we should be smart when picking dependencies, and they're not inherently bad. It's just like, evaluate them with whatever criteria and encapsulate them if possible. And that's kind of like the philosophy for point independencies. Yeah, I think that makes a lot of sense. So the phrase not invented here. Our conclusions are it's maybe not as negative an attitude as the phrase makes it sound. Yeah, I think that's a good summary. Well, this was our episode of Fatal error and runtime. Thanks for listening. You can find me online at Caleb D on Twitter. You can find me at Konglou K-H-A-N-L-O-U. You can find me online at cedzomback and we'll put a link in the show notes. Yeah, I'm Sofus Soffes. And we will see you next week on our respective Episode podcast feeds. This is a lot of fun. Absolutely. Yeah. Thanks for coming on. Thanks for the listeners. Bye. Cool.

